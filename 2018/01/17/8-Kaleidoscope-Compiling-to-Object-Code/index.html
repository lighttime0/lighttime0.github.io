<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>8. Kaleidoscope: Compiling to Object Code | LiTong&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="8.1. Chapter 8 Introduction欢迎来到“用LLVM实现一门编程语言”教程第8章。这一章将描述如何将我们的语言编译成目标文件。">
<meta property="og:type" content="article">
<meta property="og:title" content="8. Kaleidoscope: Compiling to Object Code">
<meta property="og:url" content="http://yoursite.com/2018/01/17/8-Kaleidoscope-Compiling-to-Object-Code/index.html">
<meta property="og:site_name" content="LiTong&#39;s Blog">
<meta property="og:description" content="8.1. Chapter 8 Introduction欢迎来到“用LLVM实现一门编程语言”教程第8章。这一章将描述如何将我们的语言编译成目标文件。">
<meta property="og:locale" content="zh">
<meta property="og:updated_time" content="2018-01-17T09:23:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="8. Kaleidoscope: Compiling to Object Code">
<meta name="twitter:description" content="8.1. Chapter 8 Introduction欢迎来到“用LLVM实现一门编程语言”教程第8章。这一章将描述如何将我们的语言编译成目标文件。">
  
    <link rel="alternate" href="/atom.xml" title="LiTong&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiTong&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-8-Kaleidoscope-Compiling-to-Object-Code" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/17/8-Kaleidoscope-Compiling-to-Object-Code/" class="article-date">
  <time datetime="2018-01-17T09:19:51.000Z" itemprop="datePublished">2018-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      8. Kaleidoscope: Compiling to Object Code
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="8-1-Chapter-8-Introduction"><a href="#8-1-Chapter-8-Introduction" class="headerlink" title="8.1. Chapter 8 Introduction"></a>8.1. Chapter 8 Introduction</h2><p>欢迎来到“<a href="https://releases.llvm.org/5.0.0/docs/tutorial/index.html" target="_blank" rel="noopener">用LLVM实现一门编程语言</a>”教程第8章。这一章将描述如何将我们的语言编译成目标文件。</p>
<a id="more"></a>
<!-- Welcome to Chapter 8 of the “[Implementing a language with LLVM](https://releases.llvm.org/5.0.0/docs/tutorial/index.html)” tutorial. This chapter describes how to compile our language down to object files. -->
<h2 id="8-2-Choosing-a-target"><a href="#8-2-Choosing-a-target" class="headerlink" title="8.2. Choosing a target"></a>8.2. Choosing a target</h2><p>LLVM有对交叉编译的本地支持。你可以编译成本机体系结构的目标文件，或者编译成其它体系结构的目标文件，都同样简单。在本教程中，我们为本机编译目标文件。</p>
<!-- LLVM has native support for cross-compilation. You can compile to the architecture of your current machine, or just as easily compile for other architectures. In this tutorial, we’ll target the current machine. -->
<p>为了表示你编译的目标体系结构，我们使用了“target triple”字符串。它的格式是<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>（参见<a href="http://clang.llvm.org/docs/CrossCompilation.html#target-triple" target="_blank" rel="noopener">cross compilation docs</a>）。</p>
<!-- To specify the architecture that you want to target, we use a string called a “target triple”. This takes the form `<arch><sub>-<vendor>-<sys>-<abi>` (see the [cross compilation docs](http://clang.llvm.org/docs/CrossCompilation.html#target-triple)). -->
<p>作为一个例子，我们可以看看clang对本机target triple的识别：</p>
<!-- As an example, we can see what clang thinks is our current target triple: -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang --version | grep Target</span><br><span class="line">Target: x86_64-unknown-linux-gnu</span><br></pre></td></tr></table></figure>
<p>这个命令在你的机器上执行时可能会展现不同的结果，结果随机器的体系结构和操作系统而变。</p>
<!-- Running this command may show something different on your machine as you might be using a different architecture or operating system to me. -->
<p>幸运的是，我们不需要将本机的target triple写在代码中。LLVM提供<code>sys::getDefaultTargetTriple</code>，它可以返回本机的target triple。</p>
<!-- Fortunately, we don’t need to hard-code a target triple to target the current machine. LLVM provides `sys::getDefaultTargetTriple`, which returns the target triple of the current machine. -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> TargetTriple = sys::getDefaultTargetTriple();</span><br></pre></td></tr></table></figure>
<p>使用LLVM，我们不需要link所有的target functionality。举个例子，如果我们只使用JIT，那就不需要汇编printers。类似的，如果我们只面向特定体系结构，只需要链接可用于该体系结构的functionality。</p>
<!-- LLVM doesn’t require us to to link in all the target functionality. For example, if we’re just using the JIT, we don’t need the assembly printers. Similarly, if we’re only targeting certain architectures, we can only link in the functionality for those architectures. -->
<p>在本例中，为了生成object code，我们将所有的targets初始化。</p>
<!-- For this example, we’ll initialize all the targets for emitting object code. -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InitializeAllTargetInfos();</span><br><span class="line">InitializeAllTargets();</span><br><span class="line">InitializeAllTargetMCs();</span><br><span class="line">InitializeAllAsmParsers();</span><br><span class="line">InitializeAllAsmPrinters();</span><br></pre></td></tr></table></figure>
<p>现在我们可以使用target triple字符串去获取一个<code>Target</code>了：</p>
<!-- We can now use our target triple to get a `Target:` -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Error;</span><br><span class="line"><span class="keyword">auto</span> Target = TargetRegistry::lookupTarget(TargetTriple, Error);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print an error and exit if we couldn't find the requested target.</span></span><br><span class="line"><span class="comment">// This generally occurs if we've forgotten to initialise the</span></span><br><span class="line"><span class="comment">// TargetRegistry or we have a bogus target triple.</span></span><br><span class="line"><span class="keyword">if</span> (!Target) &#123;</span><br><span class="line">  errs() &lt;&lt; Error;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-Target-Machine"><a href="#8-3-Target-Machine" class="headerlink" title="8.3. Target Machine"></a>8.3. Target Machine</h2><p>我们还需要一个<code>TargetMachine</code>。这个类提供了我们的target machine的完整描述。</p>
<p>We will also need a <code>TargetMachine</code>. This class provides a complete machine description of the machine we’re targeting. If we want to target a specific feature (such as SSE) or a specific CPU (such as Intel’s Sandylake), we do so now.</p>
<p>To see which features and CPUs that LLVM knows about, we can use <code>llc</code>. For example, let’s look at x86:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ llvm-as &lt; /dev/null | llc -march=x86 -mattr=<span class="built_in">help</span></span><br><span class="line">Available CPUs <span class="keyword">for</span> this target:</span><br><span class="line"></span><br><span class="line">  amdfam10      - Select the amdfam10 processor.</span><br><span class="line">  athlon        - Select the athlon processor.</span><br><span class="line">  athlon-4      - Select the athlon-4 processor.</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">Available features <span class="keyword">for</span> this target:</span><br><span class="line"></span><br><span class="line">  16bit-mode            - 16-bit mode (i8086).</span><br><span class="line">  32bit-mode            - 32-bit mode (80386).</span><br><span class="line">  3dnow                 - Enable 3DNow! instructions.</span><br><span class="line">  3dnowa                - Enable 3DNow! Athlon instructions.</span><br></pre></td></tr></table></figure>
<p>在我们的例子中，我们将使用generic CPU，不添加任何additional features, options or relocation model。</p>
<!-- For our example, we’ll use the generic CPU without any additional features, options or relocation model. -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> CPU = <span class="string">"generic"</span>;</span><br><span class="line"><span class="keyword">auto</span> Features = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">TargetOptions opt;</span><br><span class="line"><span class="keyword">auto</span> RM = Optional&lt;Reloc::Model&gt;();</span><br><span class="line"><span class="keyword">auto</span> TargetMachine = Target-&gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);</span><br></pre></td></tr></table></figure>
<h2 id="8-4-Configuring-the-Module"><a href="#8-4-Configuring-the-Module" class="headerlink" title="8.4. Configuring the Module"></a>8.4. Configuring the Module</h2><p>现在，我们已经准备好配置我们的模型了，来识别target和data layout。严格来说，这一步并不是必须的，但是<a href="https://releases.llvm.org/5.0.0/docs/Frontend/PerformanceTips.html" target="_blank" rel="noopener">frontend performance guide</a>推荐做这一步，因为知道target和data layout有利于优化。</p>
<!-- We’re now ready to configure our module, to specify the target and data layout. This isn’t strictly necessary, but the [frontend performance guide](https://releases.llvm.org/5.0.0/docs/Frontend/PerformanceTips.html) recommends this. Optimizations benefit from knowing about the target and data layout. -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TheModule-&gt;setDataLayout(TargetMachine-&gt;createDataLayout());</span><br><span class="line">TheModule-&gt;setTargetTriple(TargetTriple);</span><br></pre></td></tr></table></figure>
<h2 id="8-5-Emit-Object-Code"><a href="#8-5-Emit-Object-Code" class="headerlink" title="8.5. Emit Object Code"></a>8.5. Emit Object Code</h2><p>现在我们准备好生成目标代码了！让我们定义一下把文件写到哪里</p>
<!-- We’re ready to emit object code! Let’s define where we want to write our file to: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Filename = <span class="string">"output.o"</span>;</span><br><span class="line"><span class="built_in">std</span>::error_code EC;</span><br><span class="line"><span class="function">raw_fd_ostream <span class="title">dest</span><span class="params">(Filename, EC, sys::fs::F_None)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EC) &#123;</span><br><span class="line">  errs() &lt;&lt; <span class="string">"Could not open file: "</span> &lt;&lt; EC.message();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们定义一个生成目标代码的pass，然后运行这个pass：</p>
<!-- Finally, we define a pass that emits object code, then we run that pass: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">legacy::PassManager pass;</span><br><span class="line"><span class="keyword">auto</span> FileType = TargetMachine::CGFT_ObjectFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TargetMachine-&gt;addPassesToEmitFile(pass, dest, FileType)) &#123;</span><br><span class="line">  errs() &lt;&lt; <span class="string">"TargetMachine can't emit a file of this type"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pass.run(*TheModule);</span><br><span class="line">dest.flush();</span><br></pre></td></tr></table></figure>
<h2 id="8-6-Putting-It-All-Together"><a href="#8-6-Putting-It-All-Together" class="headerlink" title="8.6. Putting It All Together"></a>8.6. Putting It All Together</h2><p>它能运行成功吗？让我们试一下。我们需要编译我们的代码，但是注意，llvm-config的参数和前面的章节不同了。</p>
<!-- Does it work? Let’s give it a try. We need to compile our code, but note that the arguments to llvm-config are different to the previous chapters. -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -g -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs all` -o toy</span><br></pre></td></tr></table></figure>
<p>让我们运行一下，并定义一个简单的<code>average</code>函数。完成后按Ctrl-D结束。</p>
<p>Let’s run it, and define a simple <code>average</code> function. Press Ctrl-D when you’re done.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./toy</span><br><span class="line">ready&gt; def average(x y) (x + y) * 0.5;</span><br><span class="line">^D</span><br><span class="line">Wrote output.o</span><br></pre></td></tr></table></figure>
<p>现在你有一个目标文件了！为了测试它，让我们写一个简单的程序，并和我们的输出link起来。这里是源码：</p>
<!-- We have an object file! To test it, let’s write a simple program and link it with our output. Here’s the source code: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"average of 3.0 and 4.0: "</span> &lt;&lt; average(<span class="number">3.0</span>, <span class="number">4.0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We link our program to output.o and check the result is what we expected:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ main.cpp output.o -o main</span><br><span class="line">$ ./main</span><br><span class="line">average of 3.0 and 4.0: 3.5</span><br></pre></td></tr></table></figure>
<h2 id="8-7-Full-Code-Listing"><a href="#8-7-Full-Code-Listing" class="headerlink" title="8.7. Full Code Listing"></a>8.7. Full Code Listing</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/ADT/APFloat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/ADT/Optional.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/ADT/STLExtras.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/BasicBlock.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/DerivedTypes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Function.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Instructions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/IRBuilder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/LLVMContext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/LegacyPassManager.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Module.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Type.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Verifier.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Support/FileSystem.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Support/Host.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Support/raw_ostream.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Support/TargetRegistry.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Support/TargetSelect.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Target/TargetMachine.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Target/TargetOptions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;system_error&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm::sys;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Lexer</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The lexer returns tokens [0-255] if it is an unknown character, otherwise one</span></span><br><span class="line"><span class="comment">// of these for known things.</span></span><br><span class="line"><span class="keyword">enum</span> Token &#123;</span><br><span class="line">  tok_eof = <span class="number">-1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// commands</span></span><br><span class="line">  tok_def = <span class="number">-2</span>,</span><br><span class="line">  tok_extern = <span class="number">-3</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// primary</span></span><br><span class="line">  tok_identifier = <span class="number">-4</span>,</span><br><span class="line">  tok_number = <span class="number">-5</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// control</span></span><br><span class="line">  tok_if = <span class="number">-6</span>,</span><br><span class="line">  tok_then = <span class="number">-7</span>,</span><br><span class="line">  tok_else = <span class="number">-8</span>,</span><br><span class="line">  tok_for = <span class="number">-9</span>,</span><br><span class="line">  tok_in = <span class="number">-10</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// operators</span></span><br><span class="line">  tok_binary = <span class="number">-11</span>,</span><br><span class="line">  tok_unary = <span class="number">-12</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// var definition</span></span><br><span class="line">  tok_var = <span class="number">-13</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> IdentifierStr; <span class="comment">// Filled in if tok_identifier</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> NumVal;             <span class="comment">// Filled in if tok_number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// gettok - Return the next token from standard input.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gettok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> LastChar = <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip any whitespace.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isspace</span>(LastChar))</span><br><span class="line">    LastChar = getchar();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isalpha</span>(LastChar)) &#123; <span class="comment">// identifier: [a-zA-Z][a-zA-Z0-9]*</span></span><br><span class="line">    IdentifierStr = LastChar;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalnum</span>((LastChar = getchar())))</span><br><span class="line">      IdentifierStr += LastChar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"def"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_def;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"extern"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_extern;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"if"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_if;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"then"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_then;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"else"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_else;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"for"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_for;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"in"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_in;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"binary"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_binary;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"unary"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_unary;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"var"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_var;</span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">'.'</span>) &#123; <span class="comment">// Number: [0-9.]+</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> NumStr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      NumStr += LastChar;</span><br><span class="line">      LastChar = getchar();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    NumVal = strtod(NumStr.c_str(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> tok_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (LastChar == <span class="string">'#'</span>) &#123;</span><br><span class="line">    <span class="comment">// Comment until end of line.</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      LastChar = getchar();</span><br><span class="line">    <span class="keyword">while</span> (LastChar != EOF &amp;&amp; LastChar != <span class="string">'\n'</span> &amp;&amp; LastChar != <span class="string">'\r'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LastChar != EOF)</span><br><span class="line">      <span class="keyword">return</span> gettok();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for end of file.  Don't eat the EOF.</span></span><br><span class="line">  <span class="keyword">if</span> (LastChar == EOF)</span><br><span class="line">    <span class="keyword">return</span> tok_eof;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, just return the character as its ascii value.</span></span><br><span class="line">  <span class="keyword">int</span> ThisChar = LastChar;</span><br><span class="line">  LastChar = getchar();</span><br><span class="line">  <span class="keyword">return</span> ThisChar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Abstract Syntax Tree (aka Parse Tree)</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprAST</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~ExprAST() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Value *<span class="title">codegen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NumberExprAST - Expression class for numeric literals like "1.0".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NumberExprAST(<span class="keyword">double</span> Val) : Val(Val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// VariableExprAST - Expression class for referencing a variable, like "a".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  VariableExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Name) : Name(Name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// UnaryExprAST - Expression class for a unary operator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnaryExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">char</span> Opcode;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Operand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  UnaryExprAST(<span class="keyword">char</span> Opcode, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Operand)</span><br><span class="line">      : Opcode(Opcode), Operand(<span class="built_in">std</span>::move(Operand)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinaryExprAST - Expression class for a binary operator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">char</span> Op;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS, RHS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  BinaryExprAST(<span class="keyword">char</span> Op, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS,</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; RHS)</span><br><span class="line">      : Op(Op), LHS(<span class="built_in">std</span>::move(LHS)), RHS(<span class="built_in">std</span>::move(RHS)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CallExprAST - Expression class for function calls.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Callee;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  CallExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Callee,</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args)</span><br><span class="line">      : Callee(Callee), Args(<span class="built_in">std</span>::move(Args)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// IfExprAST - Expression class for if/then/else.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IfExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Cond, Then, Else;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  IfExprAST(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Cond, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Then,</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Else)</span><br><span class="line">      : Cond(<span class="built_in">std</span>::move(Cond)), Then(<span class="built_in">std</span>::move(Then)), Else(<span class="built_in">std</span>::move(Else)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ForExprAST - Expression class for for/in.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> VarName;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Start, End, Step, Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ForExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;VarName, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Start,</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; End, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Step,</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body)</span><br><span class="line">      : VarName(VarName), Start(<span class="built_in">std</span>::move(Start)), End(<span class="built_in">std</span>::move(End)),</span><br><span class="line">        Step(<span class="built_in">std</span>::move(Step)), Body(<span class="built_in">std</span>::move(Body)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// VarExprAST - Expression class for var/in</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt;&gt; VarNames;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  VarExprAST(</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt;&gt; VarNames,</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body)</span><br><span class="line">      : VarNames(<span class="built_in">std</span>::move(VarNames)), Body(<span class="built_in">std</span>::move(Body)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// PrototypeAST - This class represents the "prototype" for a function,</span></span><br><span class="line"><span class="comment">/// which captures its name, and its argument names (thus implicitly the number</span></span><br><span class="line"><span class="comment">/// of arguments the function takes), as well as if it is an operator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args;</span><br><span class="line">  <span class="keyword">bool</span> IsOperator;</span><br><span class="line">  <span class="keyword">unsigned</span> Precedence; <span class="comment">// Precedence if a binary op.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PrototypeAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Name, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args,</span><br><span class="line">               <span class="keyword">bool</span> IsOperator = <span class="literal">false</span>, <span class="keyword">unsigned</span> Prec = <span class="number">0</span>)</span><br><span class="line">      : Name(Name), Args(<span class="built_in">std</span>::move(Args)), IsOperator(IsOperator),</span><br><span class="line">        Precedence(Prec) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Function *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isUnaryOp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> IsOperator &amp;&amp; Args.size() == <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isBinaryOp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> IsOperator &amp;&amp; Args.size() == <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">getOperatorName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    assert(isUnaryOp() || isBinaryOp());</span><br><span class="line">    <span class="keyword">return</span> Name[Name.size() - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">getBinaryPrecedence</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Precedence; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// FunctionAST - This class represents a function definition itself.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  FunctionAST(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto,</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body)</span><br><span class="line">      : Proto(<span class="built_in">std</span>::move(Proto)), Body(<span class="built_in">std</span>::move(Body)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Function *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Parser</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current</span></span><br><span class="line"><span class="comment">/// token the parser is looking at.  getNextToken reads another token from the</span></span><br><span class="line"><span class="comment">/// lexer and updates CurTok with its results.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> CurTok;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextToken</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CurTok = gettok(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinopPrecedence - This holds the precedence for each binary operator that is</span></span><br><span class="line"><span class="comment">/// defined.</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; BinopPrecedence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// GetTokPrecedence - Get the precedence of the pending binary operator token.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetTokPrecedence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isascii(CurTok))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure it's a declared binop.</span></span><br><span class="line">  <span class="keyword">int</span> TokPrec = BinopPrecedence[CurTok];</span><br><span class="line">  <span class="keyword">if</span> (TokPrec &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> TokPrec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// LogError* - These are little helper functions for error handling.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LogError(<span class="keyword">const</span> <span class="keyword">char</span> *Str) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: %s\n"</span>, Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; LogErrorP(<span class="keyword">const</span> <span class="keyword">char</span> *Str) &#123;</span><br><span class="line">  LogError(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseExpression();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// numberexpr ::= number</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseNumberExpr() &#123;</span><br><span class="line">  <span class="keyword">auto</span> Result = llvm::make_unique&lt;NumberExprAST&gt;(NumVal);</span><br><span class="line">  getNextToken(); <span class="comment">// consume the number</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(Result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// parenexpr ::= '(' expression ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseParenExpr() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat (.</span></span><br><span class="line">  <span class="keyword">auto</span> V = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected ')'"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat ).</span></span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= identifier</span></span><br><span class="line"><span class="comment">///   ::= identifier '(' expression* ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseIdentifierExpr() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> IdName = IdentifierStr;</span><br><span class="line"></span><br><span class="line">  getNextToken(); <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>) <span class="comment">// Simple variable ref.</span></span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;VariableExprAST&gt;(IdName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call.</span></span><br><span class="line">  getNextToken(); <span class="comment">// eat (</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Arg = ParseExpression())</span><br><span class="line">        Args.push_back(<span class="built_in">std</span>::move(Arg));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok == <span class="string">')'</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok != <span class="string">','</span>)</span><br><span class="line">        <span class="keyword">return</span> LogError(<span class="string">"Expected ')' or ',' in argument list"</span>);</span><br><span class="line">      getNextToken();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eat the ')'.</span></span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;CallExprAST&gt;(IdName, <span class="built_in">std</span>::move(Args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ifexpr ::= 'if' expression 'then' expression 'else' expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseIfExpr() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat the if.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// condition.</span></span><br><span class="line">  <span class="keyword">auto</span> Cond = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!Cond)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_then)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected then"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat the then</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Then = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!Then)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_else)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected else"</span>);</span><br><span class="line"></span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Else = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!Else)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;IfExprAST&gt;(<span class="built_in">std</span>::move(Cond), <span class="built_in">std</span>::move(Then),</span><br><span class="line">                                      <span class="built_in">std</span>::move(Else));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseForExpr() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat the for.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected identifier after for"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> IdName = IdentifierStr;</span><br><span class="line">  getNextToken(); <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'='</span>)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected '=' after for"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat '='.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Start = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!Start)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">','</span>)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected ',' after for start value"</span>);</span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> End = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!End)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The step value is optional.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Step;</span><br><span class="line">  <span class="keyword">if</span> (CurTok == <span class="string">','</span>) &#123;</span><br><span class="line">    getNextToken();</span><br><span class="line">    Step = ParseExpression();</span><br><span class="line">    <span class="keyword">if</span> (!Step)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_in)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected 'in' after for"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat 'in'.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Body = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!Body)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;ForExprAST&gt;(IdName, <span class="built_in">std</span>::move(Start), <span class="built_in">std</span>::move(End),</span><br><span class="line">                                       <span class="built_in">std</span>::move(Step), <span class="built_in">std</span>::move(Body));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// varexpr ::= 'var' identifier ('=' expression)?</span></span><br><span class="line"><span class="comment">//                    (',' identifier ('=' expression)?)* 'in' expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseVarExpr() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat the var.</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt;&gt; VarNames;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At least one variable name is required.</span></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected identifier after var"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> Name = IdentifierStr;</span><br><span class="line">    getNextToken(); <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the optional initializer.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Init = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (CurTok == <span class="string">'='</span>) &#123;</span><br><span class="line">      getNextToken(); <span class="comment">// eat the '='.</span></span><br><span class="line"></span><br><span class="line">      Init = ParseExpression();</span><br><span class="line">      <span class="keyword">if</span> (!Init)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VarNames.push_back(<span class="built_in">std</span>::make_pair(Name, <span class="built_in">std</span>::move(Init)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of var list, exit loop.</span></span><br><span class="line">    <span class="keyword">if</span> (CurTok != <span class="string">','</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    getNextToken(); <span class="comment">// eat the ','.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">      <span class="keyword">return</span> LogError(<span class="string">"expected identifier list after var"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At this point, we have to have 'in'.</span></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_in)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected 'in' keyword after 'var'"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat 'in'.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Body = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!Body)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;VarExprAST&gt;(<span class="built_in">std</span>::move(VarNames), <span class="built_in">std</span>::move(Body));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// primary</span></span><br><span class="line"><span class="comment">///   ::= identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= numberexpr</span></span><br><span class="line"><span class="comment">///   ::= parenexpr</span></span><br><span class="line"><span class="comment">///   ::= ifexpr</span></span><br><span class="line"><span class="comment">///   ::= forexpr</span></span><br><span class="line"><span class="comment">///   ::= varexpr</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParsePrimary() &#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"unknown token when expecting an expression"</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> ParseIdentifierExpr();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> ParseNumberExpr();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">    <span class="keyword">return</span> ParseParenExpr();</span><br><span class="line">  <span class="keyword">case</span> tok_if:</span><br><span class="line">    <span class="keyword">return</span> ParseIfExpr();</span><br><span class="line">  <span class="keyword">case</span> tok_for:</span><br><span class="line">    <span class="keyword">return</span> ParseForExpr();</span><br><span class="line">  <span class="keyword">case</span> tok_var:</span><br><span class="line">    <span class="keyword">return</span> ParseVarExpr();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// unary</span></span><br><span class="line"><span class="comment">///   ::= primary</span></span><br><span class="line"><span class="comment">///   ::= '!' unary</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseUnary() &#123;</span><br><span class="line">  <span class="comment">// If the current token is not an operator, it must be a primary expr.</span></span><br><span class="line">  <span class="keyword">if</span> (!isascii(CurTok) || CurTok == <span class="string">'('</span> || CurTok == <span class="string">','</span>)</span><br><span class="line">    <span class="keyword">return</span> ParsePrimary();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is a unary operator, read it.</span></span><br><span class="line">  <span class="keyword">int</span> Opc = CurTok;</span><br><span class="line">  getNextToken();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Operand = ParseUnary())</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;UnaryExprAST&gt;(Opc, <span class="built_in">std</span>::move(Operand));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// binoprhs</span></span><br><span class="line"><span class="comment">///   ::= ('+' unary)*</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseBinOpRHS(<span class="keyword">int</span> ExprPrec,</span><br><span class="line">                                              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS) &#123;</span><br><span class="line">  <span class="comment">// If this is a binop, find its precedence.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> TokPrec = GetTokPrecedence();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a binop that binds at least as tightly as the current binop,</span></span><br><span class="line">    <span class="comment">// consume it, otherwise we are done.</span></span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; ExprPrec)</span><br><span class="line">      <span class="keyword">return</span> LHS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Okay, we know this is a binop.</span></span><br><span class="line">    <span class="keyword">int</span> BinOp = CurTok;</span><br><span class="line">    getNextToken(); <span class="comment">// eat binop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the unary expression after the binary operator.</span></span><br><span class="line">    <span class="keyword">auto</span> RHS = ParseUnary();</span><br><span class="line">    <span class="keyword">if</span> (!RHS)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If BinOp binds less tightly with RHS than the operator after RHS, let</span></span><br><span class="line">    <span class="comment">// the pending operator take RHS as its LHS.</span></span><br><span class="line">    <span class="keyword">int</span> NextPrec = GetTokPrecedence();</span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; NextPrec) &#123;</span><br><span class="line">      RHS = ParseBinOpRHS(TokPrec + <span class="number">1</span>, <span class="built_in">std</span>::move(RHS));</span><br><span class="line">      <span class="keyword">if</span> (!RHS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge LHS/RHS.</span></span><br><span class="line">    LHS =</span><br><span class="line">        llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, <span class="built_in">std</span>::move(LHS), <span class="built_in">std</span>::move(RHS));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// expression</span></span><br><span class="line"><span class="comment">///   ::= unary binoprhs</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseExpression() &#123;</span><br><span class="line">  <span class="keyword">auto</span> LHS = ParseUnary();</span><br><span class="line">  <span class="keyword">if</span> (!LHS)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ParseBinOpRHS(<span class="number">0</span>, <span class="built_in">std</span>::move(LHS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///   ::= id '(' id* ')'</span></span><br><span class="line"><span class="comment">///   ::= binary LETTER number? (id, id)</span></span><br><span class="line"><span class="comment">///   ::= unary LETTER (id)</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParsePrototype() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> FnName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> Kind = <span class="number">0</span>; <span class="comment">// 0 = identifier, 1 = unary, 2 = binary.</span></span><br><span class="line">  <span class="keyword">unsigned</span> BinaryPrecedence = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected function name in prototype"</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    FnName = IdentifierStr;</span><br><span class="line">    Kind = <span class="number">0</span>;</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> tok_unary:</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">if</span> (!isascii(CurTok))</span><br><span class="line">      <span class="keyword">return</span> LogErrorP(<span class="string">"Expected unary operator"</span>);</span><br><span class="line">    FnName = <span class="string">"unary"</span>;</span><br><span class="line">    FnName += (<span class="keyword">char</span>)CurTok;</span><br><span class="line">    Kind = <span class="number">1</span>;</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> tok_binary:</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">if</span> (!isascii(CurTok))</span><br><span class="line">      <span class="keyword">return</span> LogErrorP(<span class="string">"Expected binary operator"</span>);</span><br><span class="line">    FnName = <span class="string">"binary"</span>;</span><br><span class="line">    FnName += (<span class="keyword">char</span>)CurTok;</span><br><span class="line">    Kind = <span class="number">2</span>;</span><br><span class="line">    getNextToken();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the precedence if present.</span></span><br><span class="line">    <span class="keyword">if</span> (CurTok == tok_number) &#123;</span><br><span class="line">      <span class="keyword">if</span> (NumVal &lt; <span class="number">1</span> || NumVal &gt; <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">return</span> LogErrorP(<span class="string">"Invalid precedence: must be 1..100"</span>);</span><br><span class="line">      BinaryPrecedence = (<span class="keyword">unsigned</span>)NumVal;</span><br><span class="line">      getNextToken();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected '(' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ArgNames;</span><br><span class="line">  <span class="keyword">while</span> (getNextToken() == tok_identifier)</span><br><span class="line">    ArgNames.push_back(IdentifierStr);</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected ')' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// success.</span></span><br><span class="line">  getNextToken(); <span class="comment">// eat ')'.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Verify right number of names for operator.</span></span><br><span class="line">  <span class="keyword">if</span> (Kind &amp;&amp; ArgNames.size() != Kind)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Invalid number of operands for operator"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;PrototypeAST&gt;(FnName, ArgNames, Kind != <span class="number">0</span>,</span><br><span class="line">                                         BinaryPrecedence);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// definition ::= 'def' prototype expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; ParseDefinition() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat def.</span></span><br><span class="line">  <span class="keyword">auto</span> Proto = ParsePrototype();</span><br><span class="line">  <span class="keyword">if</span> (!Proto)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = ParseExpression())</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto), <span class="built_in">std</span>::move(E));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// toplevelexpr ::= expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; ParseTopLevelExpr() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = ParseExpression()) &#123;</span><br><span class="line">    <span class="comment">// Make an anonymous proto.</span></span><br><span class="line">    <span class="keyword">auto</span> Proto = llvm::make_unique&lt;PrototypeAST&gt;(<span class="string">"__anon_expr"</span>,</span><br><span class="line">                                                 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto), <span class="built_in">std</span>::move(E));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// external ::= 'extern' prototype</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParseExtern() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat extern.</span></span><br><span class="line">  <span class="keyword">return</span> ParsePrototype();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Code Generation</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> LLVMContext TheContext;</span><br><span class="line"><span class="keyword">static</span> IRBuilder&lt;&gt; Builder(TheContext);</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Module&gt; TheModule;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, AllocaInst *&gt; NamedValues;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt;&gt; FunctionProtos;</span><br><span class="line"></span><br><span class="line"><span class="function">Value *<span class="title">LogErrorV</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *Str)</span> </span>&#123;</span><br><span class="line">  LogError(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Function *<span class="title">getFunction</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> Name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// First, see if the function has already been added to the current module.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> *F = TheModule-&gt;getFunction(Name))</span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If not, check whether we can codegen the declaration from some existing</span></span><br><span class="line">  <span class="comment">// prototype.</span></span><br><span class="line">  <span class="keyword">auto</span> FI = FunctionProtos.find(Name);</span><br><span class="line">  <span class="keyword">if</span> (FI != FunctionProtos.end())</span><br><span class="line">    <span class="keyword">return</span> FI-&gt;second-&gt;codegen();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If no existing prototype exists, return null.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of</span></span><br><span class="line"><span class="comment">/// the function.  This is used for mutable variables etc.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> AllocaInst *<span class="title">CreateEntryBlockAlloca</span><span class="params">(Function *TheFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;VarName)</span> </span>&#123;</span><br><span class="line">  IRBuilder&lt;&gt; TmpB(&amp;TheFunction-&gt;getEntryBlock(),</span><br><span class="line">                   TheFunction-&gt;getEntryBlock().begin());</span><br><span class="line">  <span class="keyword">return</span> TmpB.CreateAlloca(Type::getDoubleTy(TheContext), <span class="literal">nullptr</span>, VarName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *NumberExprAST::codegen() &#123;</span><br><span class="line">  <span class="keyword">return</span> ConstantFP::get(TheContext, APFloat(Val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *VariableExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Look this variable up in the function.</span></span><br><span class="line">  Value *V = NamedValues[Name];</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown variable name"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the value.</span></span><br><span class="line">  <span class="keyword">return</span> Builder.CreateLoad(V, Name.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *UnaryExprAST::codegen() &#123;</span><br><span class="line">  Value *OperandV = Operand-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!OperandV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  Function *F = getFunction(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"unary"</span>) + Opcode);</span><br><span class="line">  <span class="keyword">if</span> (!F)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown unary operator"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Builder.CreateCall(F, OperandV, <span class="string">"unop"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *BinaryExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Special case '=' because we don't want to emit the LHS as an expression.</span></span><br><span class="line">  <span class="keyword">if</span> (Op == <span class="string">'='</span>) &#123;</span><br><span class="line">    <span class="comment">// Assignment requires the LHS to be an identifier.</span></span><br><span class="line">    <span class="comment">// This assume we're building without RTTI because LLVM builds that way by</span></span><br><span class="line">    <span class="comment">// default.  If you build LLVM with RTTI this can be changed to a</span></span><br><span class="line">    <span class="comment">// dynamic_cast for automatic error checking.</span></span><br><span class="line">    VariableExprAST *LHSE = <span class="keyword">static_cast</span>&lt;VariableExprAST *&gt;(LHS.get());</span><br><span class="line">    <span class="keyword">if</span> (!LHSE)</span><br><span class="line">      <span class="keyword">return</span> LogErrorV(<span class="string">"destination of '=' must be a variable"</span>);</span><br><span class="line">    <span class="comment">// Codegen the RHS.</span></span><br><span class="line">    Value *Val = RHS-&gt;codegen();</span><br><span class="line">    <span class="keyword">if</span> (!Val)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look up the name.</span></span><br><span class="line">    Value *Variable = NamedValues[LHSE-&gt;getName()];</span><br><span class="line">    <span class="keyword">if</span> (!Variable)</span><br><span class="line">      <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown variable name"</span>);</span><br><span class="line"></span><br><span class="line">    Builder.CreateStore(Val, Variable);</span><br><span class="line">    <span class="keyword">return</span> Val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Value *L = LHS-&gt;codegen();</span><br><span class="line">  Value *R = RHS-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFAdd(L, R, <span class="string">"addtmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFSub(L, R, <span class="string">"subtmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFMul(L, R, <span class="string">"multmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    L = Builder.CreateFCmpULT(L, R, <span class="string">"cmptmp"</span>);</span><br><span class="line">    <span class="comment">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class="line">    <span class="keyword">return</span> Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), <span class="string">"booltmp"</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If it wasn't a builtin binary operator, it must be a user defined one. Emit</span></span><br><span class="line">  <span class="comment">// a call to it.</span></span><br><span class="line">  Function *F = getFunction(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"binary"</span>) + Op);</span><br><span class="line">  assert(F &amp;&amp; <span class="string">"binary operator not found!"</span>);</span><br><span class="line"></span><br><span class="line">  Value *Ops[] = &#123;L, R&#125;;</span><br><span class="line">  <span class="keyword">return</span> Builder.CreateCall(F, Ops, <span class="string">"binop"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *CallExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Look up the name in the global module table.</span></span><br><span class="line">  Function *CalleeF = getFunction(Callee);</span><br><span class="line">  <span class="keyword">if</span> (!CalleeF)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown function referenced"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If argument mismatch error.</span></span><br><span class="line">  <span class="keyword">if</span> (CalleeF-&gt;arg_size() != Args.size())</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Incorrect # arguments passed"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Value *&gt; ArgsV;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, e = Args.size(); i != e; ++i) &#123;</span><br><span class="line">    ArgsV.push_back(Args[i]-&gt;codegen());</span><br><span class="line">    <span class="keyword">if</span> (!ArgsV.back())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Builder.CreateCall(CalleeF, ArgsV, <span class="string">"calltmp"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *IfExprAST::codegen() &#123;</span><br><span class="line">  Value *CondV = Cond-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!CondV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Convert condition to a bool by comparing non-equal to 0.0.</span></span><br><span class="line">  CondV = Builder.CreateFCmpONE(</span><br><span class="line">      CondV, ConstantFP::get(TheContext, APFloat(<span class="number">0.0</span>)), <span class="string">"ifcond"</span>);</span><br><span class="line"></span><br><span class="line">  Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create blocks for the then and else cases.  Insert the 'then' block at the</span></span><br><span class="line">  <span class="comment">// end of the function.</span></span><br><span class="line">  BasicBlock *ThenBB = BasicBlock::Create(TheContext, <span class="string">"then"</span>, TheFunction);</span><br><span class="line">  BasicBlock *ElseBB = BasicBlock::Create(TheContext, <span class="string">"else"</span>);</span><br><span class="line">  BasicBlock *MergeBB = BasicBlock::Create(TheContext, <span class="string">"ifcont"</span>);</span><br><span class="line"></span><br><span class="line">  Builder.CreateCondBr(CondV, ThenBB, ElseBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit then value.</span></span><br><span class="line">  Builder.SetInsertPoint(ThenBB);</span><br><span class="line"></span><br><span class="line">  Value *ThenV = Then-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!ThenV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  Builder.CreateBr(MergeBB);</span><br><span class="line">  <span class="comment">// Codegen of 'Then' can change the current block, update ThenBB for the PHI.</span></span><br><span class="line">  ThenBB = Builder.GetInsertBlock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit else block.</span></span><br><span class="line">  TheFunction-&gt;getBasicBlockList().push_back(ElseBB);</span><br><span class="line">  Builder.SetInsertPoint(ElseBB);</span><br><span class="line"></span><br><span class="line">  Value *ElseV = Else-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!ElseV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  Builder.CreateBr(MergeBB);</span><br><span class="line">  <span class="comment">// Codegen of 'Else' can change the current block, update ElseBB for the PHI.</span></span><br><span class="line">  ElseBB = Builder.GetInsertBlock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit merge block.</span></span><br><span class="line">  TheFunction-&gt;getBasicBlockList().push_back(MergeBB);</span><br><span class="line">  Builder.SetInsertPoint(MergeBB);</span><br><span class="line">  PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class="number">2</span>, <span class="string">"iftmp"</span>);</span><br><span class="line"></span><br><span class="line">  PN-&gt;addIncoming(ThenV, ThenBB);</span><br><span class="line">  PN-&gt;addIncoming(ElseV, ElseBB);</span><br><span class="line">  <span class="keyword">return</span> PN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output for-loop as:</span></span><br><span class="line"><span class="comment">//   var = alloca double</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   start = startexpr</span></span><br><span class="line"><span class="comment">//   store start -&gt; var</span></span><br><span class="line"><span class="comment">//   goto loop</span></span><br><span class="line"><span class="comment">// loop:</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   bodyexpr</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">// loopend:</span></span><br><span class="line"><span class="comment">//   step = stepexpr</span></span><br><span class="line"><span class="comment">//   endcond = endexpr</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   curvar = load var</span></span><br><span class="line"><span class="comment">//   nextvar = curvar + step</span></span><br><span class="line"><span class="comment">//   store nextvar -&gt; var</span></span><br><span class="line"><span class="comment">//   br endcond, loop, endloop</span></span><br><span class="line"><span class="comment">// outloop:</span></span><br><span class="line">Value *ForExprAST::codegen() &#123;</span><br><span class="line">  Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an alloca for the variable in the entry block.</span></span><br><span class="line">  AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit the start code first, without 'variable' in scope.</span></span><br><span class="line">  Value *StartVal = Start-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!StartVal)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Store the value into the alloca.</span></span><br><span class="line">  Builder.CreateStore(StartVal, Alloca);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the new basic block for the loop header, inserting after current</span></span><br><span class="line">  <span class="comment">// block.</span></span><br><span class="line">  BasicBlock *LoopBB = BasicBlock::Create(TheContext, <span class="string">"loop"</span>, TheFunction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert an explicit fall through from the current block to the LoopBB.</span></span><br><span class="line">  Builder.CreateBr(LoopBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start insertion in LoopBB.</span></span><br><span class="line">  Builder.SetInsertPoint(LoopBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Within the loop, the variable is defined equal to the PHI node.  If it</span></span><br><span class="line">  <span class="comment">// shadows an existing variable, we have to restore it, so save it now.</span></span><br><span class="line">  AllocaInst *OldVal = NamedValues[VarName];</span><br><span class="line">  NamedValues[VarName] = Alloca;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit the body of the loop.  This, like any other expr, can change the</span></span><br><span class="line">  <span class="comment">// current BB.  Note that we ignore the value computed by the body, but don't</span></span><br><span class="line">  <span class="comment">// allow an error.</span></span><br><span class="line">  <span class="keyword">if</span> (!Body-&gt;codegen())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit the step value.</span></span><br><span class="line">  Value *StepVal = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (Step) &#123;</span><br><span class="line">    StepVal = Step-&gt;codegen();</span><br><span class="line">    <span class="keyword">if</span> (!StepVal)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If not specified, use 1.0.</span></span><br><span class="line">    StepVal = ConstantFP::get(TheContext, APFloat(<span class="number">1.0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the end condition.</span></span><br><span class="line">  Value *EndCond = End-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!EndCond)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reload, increment, and restore the alloca.  This handles the case where</span></span><br><span class="line">  <span class="comment">// the body of the loop mutates the variable.</span></span><br><span class="line">  Value *CurVar = Builder.CreateLoad(Alloca, VarName.c_str());</span><br><span class="line">  Value *NextVar = Builder.CreateFAdd(CurVar, StepVal, <span class="string">"nextvar"</span>);</span><br><span class="line">  Builder.CreateStore(NextVar, Alloca);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Convert condition to a bool by comparing non-equal to 0.0.</span></span><br><span class="line">  EndCond = Builder.CreateFCmpONE(</span><br><span class="line">      EndCond, ConstantFP::get(TheContext, APFloat(<span class="number">0.0</span>)), <span class="string">"loopcond"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the "after loop" block and insert it.</span></span><br><span class="line">  BasicBlock *AfterBB =</span><br><span class="line">      BasicBlock::Create(TheContext, <span class="string">"afterloop"</span>, TheFunction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert the conditional branch into the end of LoopEndBB.</span></span><br><span class="line">  Builder.CreateCondBr(EndCond, LoopBB, AfterBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Any new code will be inserted in AfterBB.</span></span><br><span class="line">  Builder.SetInsertPoint(AfterBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restore the unshadowed variable.</span></span><br><span class="line">  <span class="keyword">if</span> (OldVal)</span><br><span class="line">    NamedValues[VarName] = OldVal;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    NamedValues.erase(VarName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for expr always returns 0.0.</span></span><br><span class="line">  <span class="keyword">return</span> Constant::getNullValue(Type::getDoubleTy(TheContext));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *VarExprAST::codegen() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;AllocaInst *&gt; OldBindings;</span><br><span class="line"></span><br><span class="line">  Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register all variables and emit their initializer.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, e = VarNames.size(); i != e; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;VarName = VarNames[i].first;</span><br><span class="line">    ExprAST *Init = VarNames[i].second.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emit the initializer before adding the variable to scope, this prevents</span></span><br><span class="line">    <span class="comment">// the initializer from referencing the variable itself, and permits stuff</span></span><br><span class="line">    <span class="comment">// like this:</span></span><br><span class="line">    <span class="comment">//  var a = 1 in</span></span><br><span class="line">    <span class="comment">//    var a = a in ...   # refers to outer 'a'.</span></span><br><span class="line">    Value *InitVal;</span><br><span class="line">    <span class="keyword">if</span> (Init) &#123;</span><br><span class="line">      InitVal = Init-&gt;codegen();</span><br><span class="line">      <span class="keyword">if</span> (!InitVal)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// If not specified, use 0.0.</span></span><br><span class="line">      InitVal = ConstantFP::get(TheContext, APFloat(<span class="number">0.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);</span><br><span class="line">    Builder.CreateStore(InitVal, Alloca);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember the old variable binding so that we can restore the binding when</span></span><br><span class="line">    <span class="comment">// we unrecurse.</span></span><br><span class="line">    OldBindings.push_back(NamedValues[VarName]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember this binding.</span></span><br><span class="line">    NamedValues[VarName] = Alloca;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Codegen the body, now that all vars are in scope.</span></span><br><span class="line">  Value *BodyVal = Body-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!BodyVal)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pop all our variables from scope.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, e = VarNames.size(); i != e; ++i)</span><br><span class="line">    NamedValues[VarNames[i].first] = OldBindings[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the body computation.</span></span><br><span class="line">  <span class="keyword">return</span> BodyVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function *PrototypeAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Make the function type:  double(double,double) etc.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type *&gt; Doubles(Args.size(), Type::getDoubleTy(TheContext));</span><br><span class="line">  FunctionType *FT =</span><br><span class="line">      FunctionType::get(Type::getDoubleTy(TheContext), Doubles, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  Function *F =</span><br><span class="line">      Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set names for all arguments.</span></span><br><span class="line">  <span class="keyword">unsigned</span> Idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : F-&gt;args())</span><br><span class="line">    Arg.setName(Args[Idx++]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function *FunctionAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Transfer ownership of the prototype to the FunctionProtos map, but keep a</span></span><br><span class="line">  <span class="comment">// reference to it for use below.</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;P = *Proto;</span><br><span class="line">  FunctionProtos[Proto-&gt;getName()] = <span class="built_in">std</span>::move(Proto);</span><br><span class="line">  Function *TheFunction = getFunction(P.getName());</span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is an operator, install it.</span></span><br><span class="line">  <span class="keyword">if</span> (P.isBinaryOp())</span><br><span class="line">    BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new basic block to start insertion into.</span></span><br><span class="line">  BasicBlock *BB = BasicBlock::Create(TheContext, <span class="string">"entry"</span>, TheFunction);</span><br><span class="line">  Builder.SetInsertPoint(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">  NamedValues.clear();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;args()) &#123;</span><br><span class="line">    <span class="comment">// Create an alloca for this variable.</span></span><br><span class="line">    AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the initial value into the alloca.</span></span><br><span class="line">    Builder.CreateStore(&amp;Arg, Alloca);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add arguments to variable symbol table.</span></span><br><span class="line">    NamedValues[Arg.getName()] = Alloca;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Value *RetVal = Body-&gt;codegen()) &#123;</span><br><span class="line">    <span class="comment">// Finish off the function.</span></span><br><span class="line">    Builder.CreateRet(RetVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate the generated code, checking for consistency.</span></span><br><span class="line">    verifyFunction(*TheFunction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TheFunction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Error reading body, remove function.</span></span><br><span class="line">  TheFunction-&gt;eraseFromParent();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (P.isBinaryOp())</span><br><span class="line">    BinopPrecedence.erase(P.getOperatorName());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Top-Level parsing and JIT Driver</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeModuleAndPassManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Open a new module.</span></span><br><span class="line">  TheModule = llvm::make_unique&lt;Module&gt;(<span class="string">"my cool jit"</span>, TheContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = ParseDefinition()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = FnAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read function definition:"</span>);</span><br><span class="line">      FnIR-&gt;print(errs());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> ProtoAST = ParseExtern()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = ProtoAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read extern: "</span>);</span><br><span class="line">      FnIR-&gt;print(errs());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">      FunctionProtos[ProtoAST-&gt;getName()] = <span class="built_in">std</span>::move(ProtoAST);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleTopLevelExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Evaluate a top-level expression into an anonymous function.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = ParseTopLevelExpr()) &#123;</span><br><span class="line">    FnAST-&gt;codegen();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// top ::= definition | external | expression | ';'</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">    <span class="keyword">case</span> tok_eof:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">';'</span>: <span class="comment">// ignore top-level semicolons.</span></span><br><span class="line">      getNextToken();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_def:</span><br><span class="line">      HandleDefinition();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_extern:</span><br><span class="line">      HandleExtern();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      HandleTopLevelExpression();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// "Library" functions that can be "extern'd" from user code.</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LLVM_ON_WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLEXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLEXPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// putchard - putchar that takes a double and returns 0.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">DLLEXPORT <span class="keyword">double</span> <span class="title">putchard</span><span class="params">(<span class="keyword">double</span> X)</span> </span>&#123;</span><br><span class="line">  fputc((<span class="keyword">char</span>)X, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// printd - printf that takes a double prints it as "%f\n", returning 0.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">DLLEXPORT <span class="keyword">double</span> <span class="title">printd</span><span class="params">(<span class="keyword">double</span> X)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%f\n"</span>, X);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Main driver code.</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">'&lt;'</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'+'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'-'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'*'</span>] = <span class="number">40</span>; <span class="comment">// highest.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prime the first token.</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ready&gt; "</span>);</span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  InitializeModuleAndPassManager();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the main "interpreter loop" now.</span></span><br><span class="line">  MainLoop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the target registry etc.</span></span><br><span class="line">  InitializeAllTargetInfos();</span><br><span class="line">  InitializeAllTargets();</span><br><span class="line">  InitializeAllTargetMCs();</span><br><span class="line">  InitializeAllAsmParsers();</span><br><span class="line">  InitializeAllAsmPrinters();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> TargetTriple = sys::getDefaultTargetTriple();</span><br><span class="line">  TheModule-&gt;setTargetTriple(TargetTriple);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Error;</span><br><span class="line">  <span class="keyword">auto</span> Target = TargetRegistry::lookupTarget(TargetTriple, Error);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print an error and exit if we couldn't find the requested target.</span></span><br><span class="line">  <span class="comment">// This generally occurs if we've forgotten to initialise the</span></span><br><span class="line">  <span class="comment">// TargetRegistry or we have a bogus target triple.</span></span><br><span class="line">  <span class="keyword">if</span> (!Target) &#123;</span><br><span class="line">    errs() &lt;&lt; Error;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> CPU = <span class="string">"generic"</span>;</span><br><span class="line">  <span class="keyword">auto</span> Features = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  TargetOptions opt;</span><br><span class="line">  <span class="keyword">auto</span> RM = Optional&lt;Reloc::Model&gt;();</span><br><span class="line">  <span class="keyword">auto</span> TheTargetMachine =</span><br><span class="line">      Target-&gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);</span><br><span class="line"></span><br><span class="line">  TheModule-&gt;setDataLayout(TheTargetMachine-&gt;createDataLayout());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Filename = <span class="string">"output.o"</span>;</span><br><span class="line">  <span class="built_in">std</span>::error_code EC;</span><br><span class="line">  <span class="function">raw_fd_ostream <span class="title">dest</span><span class="params">(Filename, EC, sys::fs::F_None)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (EC) &#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">"Could not open file: "</span> &lt;&lt; EC.message();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  legacy::PassManager pass;</span><br><span class="line">  <span class="keyword">auto</span> FileType = TargetMachine::CGFT_ObjectFile;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TheTargetMachine-&gt;addPassesToEmitFile(pass, dest, FileType)) &#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">"TheTargetMachine can't emit a file of this type"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pass.run(*TheModule);</span><br><span class="line">  dest.flush();</span><br><span class="line"></span><br><span class="line">  outs() &lt;&lt; <span class="string">"Wrote "</span> &lt;&lt; Filename &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/17/8-Kaleidoscope-Compiling-to-Object-Code/" data-id="cjciv10w4000bgh5i36zqnkao" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/01/12/6-Kaleidoscope-Extending-the-Language-User-defined-Operators/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">6. Kaleidoscope: Extending the Language: User-defined Operators</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM-Tutorial/">LLVM Tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/LLVM-Tutorial/" style="font-size: 10px;">LLVM Tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/17/8-Kaleidoscope-Compiling-to-Object-Code/">8. Kaleidoscope: Compiling to Object Code</a>
          </li>
        
          <li>
            <a href="/2018/01/12/6-Kaleidoscope-Extending-the-Language-User-defined-Operators/">6. Kaleidoscope: Extending the Language: User-defined Operators</a>
          </li>
        
          <li>
            <a href="/2018/01/12/5-Kaleidoscope-Extending-the-Language-Control-Flow/">5. Kaleidoscope: Extending the Language: Control Flow</a>
          </li>
        
          <li>
            <a href="/2018/01/11/4-Kaleidoscope-Adding-JIT-and-Optimizer-Support/">4. Kaleidoscope: Adding JIT and Optimizer Support</a>
          </li>
        
          <li>
            <a href="/2018/01/11/3-Kaleidoscope-Code-generation-to-LLVM-IR/">3. Kaleidoscope: Code generation to LLVM IR</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LiTong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>