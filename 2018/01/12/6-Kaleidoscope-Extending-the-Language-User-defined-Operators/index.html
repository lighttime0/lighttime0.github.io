<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>6. Kaleidoscope: Extending the Language: User-defined Operators | LiTong&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="6.1. Chapter 6 Introduction欢迎来到“用LLVM实现一门编程语言”教程第6章。教程到了现在，我们已经有了一个函数式的编程语言，虽然它的功能很少，但已经可以使用了。然而，还有一个很大的问题没有解决。我们的语言目前缺少很多有用的运算符（比如除法、逻辑否，以及除了小于以外的任何二元比较运算符）。">
<meta name="keywords" content="LLVM Tutorial">
<meta property="og:type" content="article">
<meta property="og:title" content="6. Kaleidoscope: Extending the Language: User-defined Operators">
<meta property="og:url" content="http://yoursite.com/2018/01/12/6-Kaleidoscope-Extending-the-Language-User-defined-Operators/index.html">
<meta property="og:site_name" content="LiTong&#39;s Blog">
<meta property="og:description" content="6.1. Chapter 6 Introduction欢迎来到“用LLVM实现一门编程语言”教程第6章。教程到了现在，我们已经有了一个函数式的编程语言，虽然它的功能很少，但已经可以使用了。然而，还有一个很大的问题没有解决。我们的语言目前缺少很多有用的运算符（比如除法、逻辑否，以及除了小于以外的任何二元比较运算符）。">
<meta property="og:locale" content="zh">
<meta property="og:updated_time" content="2018-01-12T12:50:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="6. Kaleidoscope: Extending the Language: User-defined Operators">
<meta name="twitter:description" content="6.1. Chapter 6 Introduction欢迎来到“用LLVM实现一门编程语言”教程第6章。教程到了现在，我们已经有了一个函数式的编程语言，虽然它的功能很少，但已经可以使用了。然而，还有一个很大的问题没有解决。我们的语言目前缺少很多有用的运算符（比如除法、逻辑否，以及除了小于以外的任何二元比较运算符）。">
  
    <link rel="alternate" href="/atom.xml" title="LiTong&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiTong&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-6-Kaleidoscope-Extending-the-Language-User-defined-Operators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/12/6-Kaleidoscope-Extending-the-Language-User-defined-Operators/" class="article-date">
  <time datetime="2018-01-12T12:44:41.000Z" itemprop="datePublished">2018-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      6. Kaleidoscope: Extending the Language: User-defined Operators
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="6-1-Chapter-6-Introduction"><a href="#6-1-Chapter-6-Introduction" class="headerlink" title="6.1. Chapter 6 Introduction"></a>6.1. Chapter 6 Introduction</h2><p>欢迎来到“<a href="https://releases.llvm.org/5.0.0/docs/tutorial/index.html" target="_blank" rel="noopener">用LLVM实现一门编程语言</a>”教程第6章。教程到了现在，我们已经有了一个函数式的编程语言，虽然它的功能很少，但已经可以使用了。然而，还有一个很大的问题没有解决。我们的语言目前缺少很多有用的运算符（比如除法、逻辑否，以及除了小于以外的任何二元比较运算符）。</p>
<a id="more"></a>
<!-- Welcome to Chapter 6 of the “[Implementing a language with LLVM](https://releases.llvm.org/5.0.0/docs/tutorial/index.html)” tutorial. At this point in our tutorial, we now have a fully functional language that is fairly minimal, but also useful. There is still one big problem with it, however. Our language doesn’t have many useful operators (like division, logical negation, or even any comparisons besides less-than). -->
<p>这一章将会增加用户定义的运算符，这使得Kaleidoscope不再那么简洁和优雅。某种程度上来说，这一章的改变将带给我们一门简洁丑陋的语言，但同时也是一门强大的语言。创建你自己的编程语言的一个好处是你可以决定什么好，什么不好。在我们的教程中我们将用这种方式来展示有趣的语法分析技术。</p>
<!-- This chapter of the tutorial takes a wild digression into adding user-defined operators to the simple and beautiful Kaleidoscope language. This digression now gives us a simple and ugly language in some ways, but also a powerful one at the same time. One of the great things about creating your own language is that you get to decide what is good or bad. In this tutorial we’ll assume that it is okay to use this as a way to show some interesting parsing techniques. -->
<p>在教程最后，我们将会运行一个Kaleidoscope语言的样例程序<a href="https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl06.html#kicking-the-tires" target="_blank" rel="noopener">renders the Mandelbrot set</a>。这是一个让你了解你可以用Kaleidoscope做什么以及Kaleidoscope的特性的例子。</p>
<!-- At the end of this tutorial, we’ll run through an example Kaleidoscope application that [renders the Mandelbrot set](https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl06.html#kicking-the-tires). This gives an example of what you can build with Kaleidoscope and its feature set. -->
<h2 id="6-2-User-defined-Operators-the-Idea"><a href="#6-2-User-defined-Operators-the-Idea" class="headerlink" title="6.2. User-defined Operators: the Idea"></a>6.2. User-defined Operators: the Idea</h2><p>我们将在Kaleidoscope中添加的“过多的运算符”比C++等语言的运算符更一般化。在C++中，你只能重定义已有的运算符：你不能修改语法，不能引入新的运算符，不能修改优先级，等等。在这一章中，我们将为Kaleidoscope增加这样的能力，让用户充实一下语言所支持的运算符。</p>
<!-- The “operator overloading” that we will add to Kaleidoscope is more general than in languages like C++. In C++, you are only allowed to redefine existing operators: you can’t programmatically change the grammar, introduce new operators, change precedence levels, etc. In this chapter, we will add this capability to Kaleidoscope, which will let the user round out the set of operators that are supported. -->
<p>教程中这部分像这样添加用户定义的运算符展示了手写语法分析的能力和灵活性。目前为止，我们实现的语法分析器使用递归下降的方法处理大部分的语法，用运算符优先文法对表达式进行语法分析。具体细节请看<a href="https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl02.html" target="_blank" rel="noopener">Chapter 2</a>。使用运算符优先文法，可以让程序员很方便地在语法中添加新的运算符：在JIT运行时语法是动态可扩展的。</p>
<!-- The point of going into user-defined operators in a tutorial like this is to show the power and flexibility of using a hand-written parser. Thus far, the parser we have been implementing uses recursive descent for most parts of the grammar and operator precedence parsing for the expressions. See [Chapter 2](https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl02.html) for details. By using operator precedence parsing, it is very easy to allow the programmer to introduce new operators into the grammar: the grammar is dynamically extensible as the JIT runs. -->
<p>我们将要添加的两个具体特性是可编程一元运算符（至今为止Kaleidoscope完全没有一元运算符）和二元运算符。下面是一个例子：</p>
<!-- The two specific features we’ll add are programmable unary operators (right now, Kaleidoscope has no unary operators at all) as well as binary operators. An example of this is: -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Logical unary not.</span><br><span class="line">def unary!(v)</span><br><span class="line">  if v then</span><br><span class="line">    0</span><br><span class="line">  else</span><br><span class="line">    1;</span><br><span class="line"></span><br><span class="line"># Define &gt; with the same precedence as &lt;.</span><br><span class="line">def binary&gt; 10 (LHS RHS)</span><br><span class="line">  RHS &lt; LHS;</span><br><span class="line"></span><br><span class="line"># Binary &quot;logical or&quot;, (note that it does not &quot;short circuit&quot;)</span><br><span class="line">def binary| 5 (LHS RHS)</span><br><span class="line">  if LHS then</span><br><span class="line">    1</span><br><span class="line">  else if RHS then</span><br><span class="line">    1</span><br><span class="line">  else</span><br><span class="line">    0;</span><br><span class="line"></span><br><span class="line"># Define = with slightly lower precedence than relationals.</span><br><span class="line">def binary= 9 (LHS RHS)</span><br><span class="line">  !(LHS &lt; RHS | LHS &gt; RHS);</span><br></pre></td></tr></table></figure>
<p>许多编程语言希望能够在语言内部实现自己的标准运行库。在Kaleidoscope中，我们在库中实现语言很重要的部分。</p>
<!-- Many languages aspire to being able to implement their standard runtime library in the language itself. In Kaleidoscope, we can implement significant parts of the language in the library! -->
<p>我们将这些特性分成两部分实现：实现用户定义的二元运算符以及增加一元运算符。</p>
<!-- We will break down implementation of these features into two parts: implementing support for user-defined binary operators and adding unary operators. -->
<h2 id="6-3-User-defined-Binary-Operators"><a href="#6-3-User-defined-Binary-Operators" class="headerlink" title="6.3. User-defined Binary Operators"></a>6.3. User-defined Binary Operators</h2><p>用我们现在的框架增加用户定义二元运算符的支持是相当简单的。首先我们增加一元/二元关键字：</p>
<!-- Adding support for user-defined binary operators is pretty simple with our current framework. We’ll first add support for the unary/binary keywords: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Token &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// operators</span></span><br><span class="line">  tok_binary = <span class="number">-11</span>,</span><br><span class="line">  tok_unary = <span class="number">-12</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gettok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"for"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_for;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"in"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_in;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"binary"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_binary;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"unary"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_unary;</span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br></pre></td></tr></table></figure>
<p>上面的代码只在词法分析器中增加了一元和二元关键字，就像我们在<a href="https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl5.html#lexer-extensions-for-if-then-else" target="_blank" rel="noopener">previous chapters</a>中做的那样。我们现在的AST的一个很好的特点是，二元运算符全部用它们的ASCII码值作为opcode。我们扩展运算符时，也将使用相同的表示方法，所以我们不需要一个新的AST或者语法分析器。</p>
<!-- This just adds lexer support for the unary and binary keywords, like we did in [previous chapters](https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl5.html#lexer-extensions-for-if-then-else). One nice thing about our current AST, is that we represent binary operators with full generalisation by using their ASCII code as the opcode. For our extended operators, we’ll use this same representation, so we don’t need any new AST or parser support. -->
<p>另一方面，我们需要表示这些新运算符的定义，在函数定义中的“def binary| 5”部分。在我们至今的语法中，函数定义的“name”作为“原型”进行语法分析，并保存到<code>PrototypeAST</code> AST节点中。为了将我们新定义的运算符表示为原型，我们必须如下扩展<code>PrototypeAST</code> AST节点：</p>
<!-- On the other hand, we have to be able to represent the definitions of these new operators, in the “def binary| 5” part of the function definition. In our grammar so far, the “name” for the function definition is parsed as the “prototype” production and into the `PrototypeAST` AST node. To represent our new user-defined operators as prototypes, we have to extend the `PrototypeAST` AST node like this: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// PrototypeAST - This class represents the "prototype" for a function,</span></span><br><span class="line"><span class="comment">/// which captures its argument names as well as if it is an operator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args;</span><br><span class="line">  <span class="keyword">bool</span> IsOperator;</span><br><span class="line">  <span class="keyword">unsigned</span> Precedence;  <span class="comment">// Precedence if a binary op.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PrototypeAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args,</span><br><span class="line">               <span class="keyword">bool</span> IsOperator = <span class="literal">false</span>, <span class="keyword">unsigned</span> Prec = <span class="number">0</span>)</span><br><span class="line">  : Name(name), Args(<span class="built_in">std</span>::move(Args)), IsOperator(IsOperator),</span><br><span class="line">    Precedence(Prec) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Function *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isUnaryOp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> IsOperator &amp;&amp; Args.size() == <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isBinaryOp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> IsOperator &amp;&amp; Args.size() == <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">getOperatorName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    assert(isUnaryOp() || isBinaryOp());</span><br><span class="line">    <span class="keyword">return</span> Name[Name.size() - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">getBinaryPrecedence</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Precedence; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基本思路是，现在出了要知道prototype的名称外，我们还要追踪，看它是否是一个运算符，如果是的话，它的优先级是多少。优先级只适用于二元运算符（下面将会看到，优先级不用于一元运算符）。现在，我们有表示用户定义运算符的原型的方法了，我们需要进行语法分析：</p>
<!-- Basically, in addition to knowing a name for the prototype, we now keep track of whether it was an operator, and if it was, what precedence level the operator is at. The precedence is only used for binary operators (as you’ll see below, it just doesn’t apply for unary operators). Now that we have a way to represent the prototype for a user-defined operator, we need to parse it: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///   ::= id '(' id* ')'</span></span><br><span class="line"><span class="comment">///   ::= binary LETTER number? (id, id)</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParsePrototype() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> FnName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> Kind = <span class="number">0</span>;  <span class="comment">// 0 = identifier, 1 = unary, 2 = binary.</span></span><br><span class="line">  <span class="keyword">unsigned</span> BinaryPrecedence = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected function name in prototype"</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    FnName = IdentifierStr;</span><br><span class="line">    Kind = <span class="number">0</span>;</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> tok_binary:</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">if</span> (!isascii(CurTok))</span><br><span class="line">      <span class="keyword">return</span> LogErrorP(<span class="string">"Expected binary operator"</span>);</span><br><span class="line">    FnName = <span class="string">"binary"</span>;</span><br><span class="line">    FnName += (<span class="keyword">char</span>)CurTok;</span><br><span class="line">    Kind = <span class="number">2</span>;</span><br><span class="line">    getNextToken();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the precedence if present.</span></span><br><span class="line">    <span class="keyword">if</span> (CurTok == tok_number) &#123;</span><br><span class="line">      <span class="keyword">if</span> (NumVal &lt; <span class="number">1</span> || NumVal &gt; <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">return</span> LogErrorP(<span class="string">"Invalid precedence: must be 1..100"</span>);</span><br><span class="line">      BinaryPrecedence = (<span class="keyword">unsigned</span>)NumVal;</span><br><span class="line">      getNextToken();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected '(' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ArgNames;</span><br><span class="line">  <span class="keyword">while</span> (getNextToken() == tok_identifier)</span><br><span class="line">    ArgNames.push_back(IdentifierStr);</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected ')' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// success.</span></span><br><span class="line">  getNextToken();  <span class="comment">// eat ')'.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Verify right number of names for operator.</span></span><br><span class="line">  <span class="keyword">if</span> (Kind &amp;&amp; ArgNames.size() != Kind)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Invalid number of operands for operator"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;PrototypeAST&gt;(FnName, <span class="built_in">std</span>::move(ArgNames), Kind != <span class="number">0</span>,</span><br><span class="line">                                         BinaryPrecedence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些都是比较直观的语法分析的代码，我们之前已经有很多类似的代码了。这段代码有意思的一个部分是为二元运算符设置<code>FnName</code>的几行。举例来说，它会为新定义的“@”运算符构造类似于“binary@”的名字。然后，它会利用LLVM symbol table中的symbol names允许任意字符（包括空字符）的特点。</p>
<!-- This is all fairly straightforward parsing code, and we have already seen a lot of similar code in the past. One interesting part about the code above is the couple lines that set up `FnName` for binary operators. This builds names like “binary@” for a newly defined “@” operator. It then takes advantage of the fact that symbol names in the LLVM symbol table are allowed to have any character in them, including embedded nul characters. -->
<p>下一个要添加的有意思的事情是，为这些二元运算符添加codegen支持。在我们当前的结构中，这是一次很简单的添加，只需要我们已有的二元运算符节点增加一个default case即可。</p>
<!-- The next interesting thing to add, is codegen support for these binary operators. Given our current structure, this is a simple addition of a default case for our existing binary operator node: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Value *BinaryExprAST::codegen() &#123;</span><br><span class="line">  Value *L = LHS-&gt;codegen();</span><br><span class="line">  Value *R = RHS-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFAdd(L, R, <span class="string">"addtmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFSub(L, R, <span class="string">"subtmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFMul(L, R, <span class="string">"multmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    L = Builder.CreateFCmpULT(L, R, <span class="string">"cmptmp"</span>);</span><br><span class="line">    <span class="comment">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class="line">    <span class="keyword">return</span> Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext),</span><br><span class="line">                                <span class="string">"booltmp"</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If it wasn't a builtin binary operator, it must be a user defined one. Emit</span></span><br><span class="line">  <span class="comment">// a call to it.</span></span><br><span class="line">  Function *F = getFunction(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"binary"</span>) + Op);</span><br><span class="line">  assert(F &amp;&amp; <span class="string">"binary operator not found!"</span>);</span><br><span class="line"></span><br><span class="line">  Value *Ops[<span class="number">2</span>] = &#123; L, R &#125;;</span><br><span class="line">  <span class="keyword">return</span> Builder.CreateCall(F, Ops, <span class="string">"binop"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你在上面看到的那样，新代码实际上很简单。它知识在symbol table中搜索一个合适的运算符，并且生成一个调用它的函数。因为用户定义的运算符会按照常规的函数构造（因为“prototype” boils down to a function with the right name），everything falls into place。</p>
<!-- As you can see above, the new code is actually really simple. It just does a lookup for the appropriate operator in the symbol table and generates a function call to it. Since user-defined operators are just built as normal functions (because the “prototype” boils down to a function with the right name) everything falls into place. -->
<p>最后一部分代码我们省略了，is a bit of top-level magic：</p>
<!-- The final piece of code we are missing, is a bit of top-level magic: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function *FunctionAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Transfer ownership of the prototype to the FunctionProtos map, but keep a</span></span><br><span class="line">  <span class="comment">// reference to it for use below.</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;P = *Proto;</span><br><span class="line">  FunctionProtos[Proto-&gt;getName()] = <span class="built_in">std</span>::move(Proto);</span><br><span class="line">  Function *TheFunction = getFunction(P.getName());</span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is an operator, install it.</span></span><br><span class="line">  <span class="keyword">if</span> (P.isBinaryOp())</span><br><span class="line">    BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new basic block to start insertion into.</span></span><br><span class="line">  BasicBlock *BB = BasicBlock::Create(TheContext, <span class="string">"entry"</span>, TheFunction);</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>本质上来说，在codegen一个函数钱，如果它是一个用户定义的运算符，我们将它注册在优先级表中。This allows the binary operator parsing logic we already have in place to handle it. Since we are working on a fully-general operator precedence parser, this is all we need to do to “extend the grammar”.</p>
<!-- Basically, before codegening a function, if it is a user-defined operator, we register it in the precedence table. This allows the binary operator parsing logic we already have in place to handle it. Since we are working on a fully-general operator precedence parser, this is all we need to do to “extend the grammar”. -->
<p>现在我们有强力的用户定义的二元运算符了。大部分工作基于我们前面为其它运算符构造的框架。增加一元运算符会更有挑战，因为我们至今没有任何框架——让我们看看它需要哪些工作吧。</p>
<!-- Now we have useful user-defined binary operators. This builds a lot on the previous framework we built for other operators. Adding unary operators is a bit more challenging, because we don’t have any framework for it yet - lets see what it takes. -->
<h2 id="6-4-User-defined-Unary-Operators"><a href="#6-4-User-defined-Unary-Operators" class="headerlink" title="6.4. User-defined Unary Operators"></a>6.4. User-defined Unary Operators</h2><p>因为我们现在还没有在Kaleidoscope语言中增加一元运算符的支持，我们首先将添加用来支持它们的所有东西。上面我们在词法分析器中增加了对‘unary’关键字的简单支持。除此之外，我们需要一个AST节点：</p>
<!-- Since we don’t currently support unary operators in the Kaleidoscope language, we’ll need to add everything to support them. Above, we added simple support for the ‘unary’ keyword to the lexer. In addition to that, we need an AST node: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// UnaryExprAST - Expression class for a unary operator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnaryExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">char</span> Opcode;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Operand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  UnaryExprAST(<span class="keyword">char</span> Opcode, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Operand)</span><br><span class="line">    : Opcode(Opcode), Operand(<span class="built_in">std</span>::move(Operand)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个AST节点很简单，也很显而易见。它相当于直接复制了二元运算符的AST节点，除了它只有一个child以外。这些做完后，我们需要添加语法分析逻辑。对一元运算符进行语法分析很简单：我们将为它增加一个新函数：</p>
<!-- This AST node is very simple and obvious by now. It directly mirrors the binary operator AST node, except that it only has one child. With this, we need to add the parsing logic. Parsing a unary operator is pretty simple: we’ll add a new function to do it: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// unary</span></span><br><span class="line"><span class="comment">///   ::= primary</span></span><br><span class="line"><span class="comment">///   ::= '!' unary</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseUnary() &#123;</span><br><span class="line">  <span class="comment">// If the current token is not an operator, it must be a primary expr.</span></span><br><span class="line">  <span class="keyword">if</span> (!isascii(CurTok) || CurTok == <span class="string">'('</span> || CurTok == <span class="string">','</span>)</span><br><span class="line">    <span class="keyword">return</span> ParsePrimary();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is a unary operator, read it.</span></span><br><span class="line">  <span class="keyword">int</span> Opc = CurTok;</span><br><span class="line">  getNextToken();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Operand = ParseUnary())</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;UnaryExprAST&gt;(Opc, <span class="built_in">std</span>::move(Operand));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里添加的语法很直观。当对一个primary operator进行语法分析时，如果看到一个一元运算符，我们将这个运算符吃掉，作为一个前缀，然后将剩下的部分作为另一个一元运算符进行语法分析。这就允许我们处理多个一元运算符（比如“!!x“）。注意，一元运算符不能像二元运算符那样有歧义，所以不需要优先级。</p>
<!-- The grammar we add is pretty straightforward here. If we see a unary operator when parsing a primary operator, we eat the operator as a prefix and parse the remaining piece as another unary operator. This allows us to handle multiple unary operators (e.g. ”!!x”). Note that unary operators can’t have ambiguous parses like binary operators can, so there is no need for precedence information. -->
<p>这个函数的问题时我们需要在某处调用ParseUnary。为此，我们修改了之前ParsePrimary的调用者，用ParseUnary替换：</p>
<!-- The problem with this function, is that we need to call ParseUnary from somewhere. To do this, we change previous callers of ParsePrimary to call ParseUnary instead: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// binoprhs</span></span><br><span class="line"><span class="comment">///   ::= ('+' unary)*</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseBinOpRHS(<span class="keyword">int</span> ExprPrec,</span><br><span class="line">                                              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS) &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// Parse the unary expression after the binary operator.</span></span><br><span class="line">    <span class="keyword">auto</span> RHS = ParseUnary();</span><br><span class="line">    <span class="keyword">if</span> (!RHS)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// expression</span></span><br><span class="line"><span class="comment">///   ::= unary binoprhs</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseExpression() &#123;</span><br><span class="line">  <span class="keyword">auto</span> LHS = ParseUnary();</span><br><span class="line">  <span class="keyword">if</span> (!LHS)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ParseBinOpRHS(<span class="number">0</span>, <span class="built_in">std</span>::move(LHS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这两个简单的修改后，现在我们可以对一元运算符进行语法分析，并从中构造AST了。下一步，为了对一元运算符原型进行语法分析，我们需要增加原型的语法支持。我们用下面的代码扩展二元运算符的代码：</p>
<!-- With these two simple changes, we are now able to parse unary operators and build the AST for them. Next up, we need to add parser support for prototypes, to parse the unary operator prototype. We extend the binary operator code above with: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///   ::= id '(' id* ')'</span></span><br><span class="line"><span class="comment">///   ::= binary LETTER number? (id, id)</span></span><br><span class="line"><span class="comment">///   ::= unary LETTER (id)</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParsePrototype() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> FnName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> Kind = <span class="number">0</span>;  <span class="comment">// 0 = identifier, 1 = unary, 2 = binary.</span></span><br><span class="line">  <span class="keyword">unsigned</span> BinaryPrecedence = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected function name in prototype"</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    FnName = IdentifierStr;</span><br><span class="line">    Kind = <span class="number">0</span>;</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> tok_unary:</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">if</span> (!isascii(CurTok))</span><br><span class="line">      <span class="keyword">return</span> LogErrorP(<span class="string">"Expected unary operator"</span>);</span><br><span class="line">    FnName = <span class="string">"unary"</span>;</span><br><span class="line">    FnName += (<span class="keyword">char</span>)CurTok;</span><br><span class="line">    Kind = <span class="number">1</span>;</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> tok_binary:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>As with binary operators, we name unary operators with a name that includes the operator character。这会在代码生成的时候帮到我们。提到代码生成，我们最后需要增加的一段代码就是为一元运算符增加codegen支持。代码长成下面这个样子：</p>
<!-- As with binary operators, we name unary operators with a name that includes the operator character. This assists us at code generation time. Speaking of, the final piece we need to add is codegen support for unary operators. It looks like this: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Value *UnaryExprAST::codegen() &#123;</span><br><span class="line">  Value *OperandV = Operand-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!OperandV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  Function *F = getFunction(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"unary"</span>) + Opcode);</span><br><span class="line">  <span class="keyword">if</span> (!F)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown unary operator"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Builder.CreateCall(F, OperandV, <span class="string">"unop"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和二元运算符相比，上面的代码很相似，但更简单。它更简单的原因主要是它不需要处理任何预定义的运算符。</p>
<!-- This code is similar to, but simpler than, the code for binary operators. It is simpler primarily because it doesn’t need to handle any predefined operators. -->
<h2 id="6-5-Kicking-the-Tires"><a href="#6-5-Kicking-the-Tires" class="headerlink" title="6.5. Kicking the Tires"></a>6.5. Kicking the Tires</h2><p>尽管有些难以置信，但完成我们在前面的章节里提到的一些扩展后，我们开发出了一门实际可用的编程语言。我们现在可以用它做很多有意思的事情，包括I/O，数学计算，以及很多其他的事情。举例来说，我们现在可以增加一个nice sequencing operator（printd被定义为打印一个具体的值，并切换到新一行）：</p>
<!-- It is somewhat hard to believe, but with a few simple extensions we’ve covered in the last chapters, we have grown a real-ish language. With this, we can do a lot of interesting things, including I/O, math, and a bunch of other things. For example, we can now add a nice sequencing operator (printd is defined to print out the specified value and a newline): -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; extern printd(x);</span><br><span class="line">Read extern:</span><br><span class="line">declare double @printd(double)</span><br><span class="line"></span><br><span class="line">ready&gt; def binary : 1 (x y) 0;  # Low-precedence operator that ignores operands.</span><br><span class="line">...</span><br><span class="line">ready&gt; printd(123) : printd(456) : printd(789);</span><br><span class="line">123.000000</span><br><span class="line">456.000000</span><br><span class="line">789.000000</span><br><span class="line">Evaluated to 0.000000</span><br></pre></td></tr></table></figure>
<p>我们同样可以定义很多“原创的”的运算符，比如：</p>
<!-- We can also define a bunch of other “primitive” operations, such as: -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># Logical unary not.</span><br><span class="line">def unary!(v)</span><br><span class="line">  if v then</span><br><span class="line">    0</span><br><span class="line">  else</span><br><span class="line">    1;</span><br><span class="line"></span><br><span class="line"># Unary negate.</span><br><span class="line">def unary-(v)</span><br><span class="line">  0-v;</span><br><span class="line"></span><br><span class="line"># Define &gt; with the same precedence as &lt;.</span><br><span class="line">def binary&gt; 10 (LHS RHS)</span><br><span class="line">  RHS &lt; LHS;</span><br><span class="line"></span><br><span class="line"># Binary logical or, which does not short circuit.</span><br><span class="line">def binary| 5 (LHS RHS)</span><br><span class="line">  if LHS then</span><br><span class="line">    1</span><br><span class="line">  else if RHS then</span><br><span class="line">    1</span><br><span class="line">  else</span><br><span class="line">    0;</span><br><span class="line"></span><br><span class="line"># Binary logical and, which does not short circuit.</span><br><span class="line">def binary&amp; 6 (LHS RHS)</span><br><span class="line">  if !LHS then</span><br><span class="line">    0</span><br><span class="line">  else</span><br><span class="line">    !!RHS;</span><br><span class="line"></span><br><span class="line"># Define = with slightly lower precedence than relationals.</span><br><span class="line">def binary = 9 (LHS RHS)</span><br><span class="line">  !(LHS &lt; RHS | LHS &gt; RHS);</span><br><span class="line"></span><br><span class="line"># Define &apos;:&apos; for sequencing: as a low-precedence operator that ignores operands</span><br><span class="line"># and just returns the RHS.</span><br><span class="line">def binary : 1 (x y) y;</span><br></pre></td></tr></table></figure>
<p>有了前面的if/then/else的支持后，我们可以为I/O定义一些有趣的函数。比如说，下面的代码会打印字符，“density”反映了输入的值：值越低，字符越密集。</p>
<!-- Given the previous if/then/else support, we can also define interesting functions for I/O. For example, the following prints out a character whose “density” reflects the value passed in: the lower the value, the denser the character: -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; extern putchard(char);</span><br><span class="line">...</span><br><span class="line">ready&gt; def printdensity(d)</span><br><span class="line">  if d &gt; 8 then</span><br><span class="line">    putchard(32)  # &apos; &apos;</span><br><span class="line">  else if d &gt; 4 then</span><br><span class="line">    putchard(46)  # &apos;.&apos;</span><br><span class="line">  else if d &gt; 2 then</span><br><span class="line">    putchard(43)  # &apos;+&apos;</span><br><span class="line">  else</span><br><span class="line">    putchard(42); # &apos;*&apos;</span><br><span class="line">...</span><br><span class="line">ready&gt; printdensity(1): printdensity(2): printdensity(3):</span><br><span class="line">       printdensity(4): printdensity(5): printdensity(9):</span><br><span class="line">       putchard(10);</span><br><span class="line">**++.</span><br><span class="line">Evaluated to 0.000000</span><br></pre></td></tr></table></figure>
<p>基于这些简单的原创操作符，我们可以定义更有趣的东西。比如说这里是一个短小的函数，决定</p>
<p>Based on these simple primitive operations, we can start to define more interesting things. For example, here’s a little function that determines the number of iterations it takes for a certain function in the complex plane to diverge:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Determine whether the specific location diverges.</span><br><span class="line"># Solve for z = z^2 + c in the complex plane.</span><br><span class="line">def mandelconverger(real imag iters creal cimag)</span><br><span class="line">  if iters &gt; 255 | (real*real + imag*imag &gt; 4) then</span><br><span class="line">    iters</span><br><span class="line">  else</span><br><span class="line">    mandelconverger(real*real - imag*imag + creal,</span><br><span class="line">                    2*real*imag + cimag,</span><br><span class="line">                    iters+1, creal, cimag);</span><br><span class="line"></span><br><span class="line"># Return the number of iterations required for the iteration to escape</span><br><span class="line">def mandelconverge(real imag)</span><br><span class="line">  mandelconverger(real, imag, 0, real, imag);</span><br></pre></td></tr></table></figure>
<p>This “<code>z = z2 + c</code>” function is a beautiful little creature that is the basis for computation of the <a href="http://en.wikipedia.org/wiki/Mandelbrot_set" target="_blank" rel="noopener">Mandelbrot Set</a>. Our <code>mandelconverge</code> function returns the number of iterations that it takes for a complex orbit to escape, saturating to 255. This is not a very useful function by itself, but if you plot its value over a two-dimensional plane, you can see the Mandelbrot set. Given that we are limited to using putchard here, our amazing graphical output is limited, but we can whip together something using the density plotter above:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Compute and plot the mandelbrot set with the specified 2 dimensional range</span><br><span class="line"># info.</span><br><span class="line">def mandelhelp(xmin xmax xstep   ymin ymax ystep)</span><br><span class="line">  for y = ymin, y &lt; ymax, ystep in (</span><br><span class="line">    (for x = xmin, x &lt; xmax, xstep in</span><br><span class="line">       printdensity(mandelconverge(x,y)))</span><br><span class="line">    : putchard(10)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"># mandel - This is a convenient helper function for plotting the mandelbrot set</span><br><span class="line"># from the specified position with the specified Magnification.</span><br><span class="line">def mandel(realstart imagstart realmag imagmag)</span><br><span class="line">  mandelhelp(realstart, realstart+realmag*78, realmag,</span><br><span class="line">             imagstart, imagstart+imagmag*40, imagmag);</span><br></pre></td></tr></table></figure>
<p>Given this, we can try plotting out the mandelbrot set! Lets try it out:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; mandel(-2.3, -1.3, 0.05, 0.07);</span><br><span class="line">*******************************+++++++++++*************************************</span><br><span class="line">*************************+++++++++++++++++++++++*******************************</span><br><span class="line">**********************+++++++++++++++++++++++++++++****************************</span><br><span class="line">*******************+++++++++++++++++++++.. ...++++++++*************************</span><br><span class="line">*****************++++++++++++++++++++++.... ...+++++++++***********************</span><br><span class="line">***************+++++++++++++++++++++++.....   ...+++++++++*********************</span><br><span class="line">**************+++++++++++++++++++++++....     ....+++++++++********************</span><br><span class="line">*************++++++++++++++++++++++......      .....++++++++*******************</span><br><span class="line">************+++++++++++++++++++++.......       .......+++++++******************</span><br><span class="line">***********+++++++++++++++++++....                ... .+++++++*****************</span><br><span class="line">**********+++++++++++++++++.......                     .+++++++****************</span><br><span class="line">*********++++++++++++++...........                    ...+++++++***************</span><br><span class="line">********++++++++++++............                      ...++++++++**************</span><br><span class="line">********++++++++++... ..........                        .++++++++**************</span><br><span class="line">*******+++++++++.....                                   .+++++++++*************</span><br><span class="line">*******++++++++......                                  ..+++++++++*************</span><br><span class="line">*******++++++.......                                   ..+++++++++*************</span><br><span class="line">*******+++++......                                     ..+++++++++*************</span><br><span class="line">*******.... ....                                      ...+++++++++*************</span><br><span class="line">*******.... .                                         ...+++++++++*************</span><br><span class="line">*******+++++......                                    ...+++++++++*************</span><br><span class="line">*******++++++.......                                   ..+++++++++*************</span><br><span class="line">*******++++++++......                                   .+++++++++*************</span><br><span class="line">*******+++++++++.....                                  ..+++++++++*************</span><br><span class="line">********++++++++++... ..........                        .++++++++**************</span><br><span class="line">********++++++++++++............                      ...++++++++**************</span><br><span class="line">*********++++++++++++++..........                     ...+++++++***************</span><br><span class="line">**********++++++++++++++++........                     .+++++++****************</span><br><span class="line">**********++++++++++++++++++++....                ... ..+++++++****************</span><br><span class="line">***********++++++++++++++++++++++.......       .......++++++++*****************</span><br><span class="line">************+++++++++++++++++++++++......      ......++++++++******************</span><br><span class="line">**************+++++++++++++++++++++++....      ....++++++++********************</span><br><span class="line">***************+++++++++++++++++++++++.....   ...+++++++++*********************</span><br><span class="line">*****************++++++++++++++++++++++....  ...++++++++***********************</span><br><span class="line">*******************+++++++++++++++++++++......++++++++*************************</span><br><span class="line">*********************++++++++++++++++++++++.++++++++***************************</span><br><span class="line">*************************+++++++++++++++++++++++*******************************</span><br><span class="line">******************************+++++++++++++************************************</span><br><span class="line">*******************************************************************************</span><br><span class="line">*******************************************************************************</span><br><span class="line">*******************************************************************************</span><br><span class="line">Evaluated to 0.000000</span><br><span class="line">ready&gt; mandel(-2, -1, 0.02, 0.04);</span><br><span class="line">**************************+++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">***********************++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">*********************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class="line">*******************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++...</span><br><span class="line">*****************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++.....</span><br><span class="line">***************++++++++++++++++++++++++++++++++++++++++++++++++++++++++........</span><br><span class="line">**************++++++++++++++++++++++++++++++++++++++++++++++++++++++...........</span><br><span class="line">************+++++++++++++++++++++++++++++++++++++++++++++++++++++..............</span><br><span class="line">***********++++++++++++++++++++++++++++++++++++++++++++++++++........        .</span><br><span class="line">**********++++++++++++++++++++++++++++++++++++++++++++++.............</span><br><span class="line">********+++++++++++++++++++++++++++++++++++++++++++..................</span><br><span class="line">*******+++++++++++++++++++++++++++++++++++++++.......................</span><br><span class="line">******+++++++++++++++++++++++++++++++++++...........................</span><br><span class="line">*****++++++++++++++++++++++++++++++++............................</span><br><span class="line">*****++++++++++++++++++++++++++++...............................</span><br><span class="line">****++++++++++++++++++++++++++......   .........................</span><br><span class="line">***++++++++++++++++++++++++.........     ......    ...........</span><br><span class="line">***++++++++++++++++++++++............</span><br><span class="line">**+++++++++++++++++++++..............</span><br><span class="line">**+++++++++++++++++++................</span><br><span class="line">*++++++++++++++++++.................</span><br><span class="line">*++++++++++++++++............ ...</span><br><span class="line">*++++++++++++++..............</span><br><span class="line">*+++....++++................</span><br><span class="line">*..........  ...........</span><br><span class="line">*</span><br><span class="line">*..........  ...........</span><br><span class="line">*+++....++++................</span><br><span class="line">*++++++++++++++..............</span><br><span class="line">*++++++++++++++++............ ...</span><br><span class="line">*++++++++++++++++++.................</span><br><span class="line">**+++++++++++++++++++................</span><br><span class="line">**+++++++++++++++++++++..............</span><br><span class="line">***++++++++++++++++++++++............</span><br><span class="line">***++++++++++++++++++++++++.........     ......    ...........</span><br><span class="line">****++++++++++++++++++++++++++......   .........................</span><br><span class="line">*****++++++++++++++++++++++++++++...............................</span><br><span class="line">*****++++++++++++++++++++++++++++++++............................</span><br><span class="line">******+++++++++++++++++++++++++++++++++++...........................</span><br><span class="line">*******+++++++++++++++++++++++++++++++++++++++.......................</span><br><span class="line">********+++++++++++++++++++++++++++++++++++++++++++..................</span><br><span class="line">Evaluated to 0.000000</span><br><span class="line">ready&gt; mandel(-0.9, -1.4, 0.02, 0.03);</span><br><span class="line">*******************************************************************************</span><br><span class="line">*******************************************************************************</span><br><span class="line">*******************************************************************************</span><br><span class="line">**********+++++++++++++++++++++************************************************</span><br><span class="line">*+++++++++++++++++++++++++++++++++++++++***************************************</span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++**********************************</span><br><span class="line">++++++++++++++++++++++++++++++++++++++++++++++++++*****************************</span><br><span class="line">++++++++++++++++++++++++++++++++++++++++++++++++++++++*************************</span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++**********************</span><br><span class="line">+++++++++++++++++++++++++++++++++.........++++++++++++++++++*******************</span><br><span class="line">+++++++++++++++++++++++++++++++....   ......+++++++++++++++++++****************</span><br><span class="line">+++++++++++++++++++++++++++++.......  ........+++++++++++++++++++**************</span><br><span class="line">++++++++++++++++++++++++++++........   ........++++++++++++++++++++************</span><br><span class="line">+++++++++++++++++++++++++++.........     ..  ...+++++++++++++++++++++**********</span><br><span class="line">++++++++++++++++++++++++++...........        ....++++++++++++++++++++++********</span><br><span class="line">++++++++++++++++++++++++.............       .......++++++++++++++++++++++******</span><br><span class="line">+++++++++++++++++++++++.............        ........+++++++++++++++++++++++****</span><br><span class="line">++++++++++++++++++++++...........           ..........++++++++++++++++++++++***</span><br><span class="line">++++++++++++++++++++...........                .........++++++++++++++++++++++*</span><br><span class="line">++++++++++++++++++............                  ...........++++++++++++++++++++</span><br><span class="line">++++++++++++++++...............                 .............++++++++++++++++++</span><br><span class="line">++++++++++++++.................                 ...............++++++++++++++++</span><br><span class="line">++++++++++++..................                  .................++++++++++++++</span><br><span class="line">+++++++++..................                      .................+++++++++++++</span><br><span class="line">++++++........        .                               .........  ..++++++++++++</span><br><span class="line">++............                                         ......    ....++++++++++</span><br><span class="line">..............                                                    ...++++++++++</span><br><span class="line">..............                                                    ....+++++++++</span><br><span class="line">..............                                                    .....++++++++</span><br><span class="line">.............                                                    ......++++++++</span><br><span class="line">...........                                                     .......++++++++</span><br><span class="line">.........                                                       ........+++++++</span><br><span class="line">.........                                                       ........+++++++</span><br><span class="line">.........                                                           ....+++++++</span><br><span class="line">........                                                             ...+++++++</span><br><span class="line">.......                                                              ...+++++++</span><br><span class="line">                                                                    ....+++++++</span><br><span class="line">                                                                   .....+++++++</span><br><span class="line">                                                                    ....+++++++</span><br><span class="line">                                                                    ....+++++++</span><br><span class="line">                                                                    ....+++++++</span><br><span class="line">Evaluated to 0.000000</span><br><span class="line">ready&gt; ^D</span><br></pre></td></tr></table></figure>
<p>At this point, you may be starting to realize that Kaleidoscope is a real and powerful language. It may not be self-similar :), but it can be used to plot things that are!</p>
<p>With this, we conclude the “adding user-defined operators” chapter of the tutorial. We have successfully augmented our language, adding the ability to extend the language in the library, and we have shown how this can be used to build a simple but interesting end-user application in Kaleidoscope. At this point, Kaleidoscope can build a variety of applications that are functional and can call functions with side-effects, but it can’t actually define and mutate a variable itself.</p>
<p>Strikingly, variable mutation is an important feature of some languages, and it is not at all obvious how to <a href="https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl07.html" target="_blank" rel="noopener">add support for mutable variables</a> without having to add an “SSA construction” phase to your front-end. In the next chapter, we will describe how you can add variable mutation without building SSA in your front-end.</p>
<h2 id="6-6-Full-Code-Listing"><a href="#6-6-Full-Code-Listing" class="headerlink" title="6.6. Full Code Listing"></a>6.6. Full Code Listing</h2><p>这里是我们的例子的完整代码，这一章增加了用户定义运算符。用下面的指令build这个例子：</p>
<!-- Here is the complete code listing for our running example, enhanced with the support for user-defined operators. To build this example, use: -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compile</span></span><br><span class="line">clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native` -O3 -o toy</span><br><span class="line"><span class="comment"># Run</span></span><br><span class="line">./toy</span><br></pre></td></tr></table></figure>
<p>On some platforms, you will need to specify -rdynamic or -Wl,–export-dynamic when linking. This ensures that symbols defined in the main executable are exported to the dynamic linker and so are available for symbol resolution at run time. This is not needed if you compile your support code into a shared library, although doing that will cause problems on Windows.</p>
<p>下面是完整的代码：</p>
<!-- Here is the code: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/ADT/APFloat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/ADT/STLExtras.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/BasicBlock.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/DerivedTypes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Function.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Instructions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/IRBuilder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/LLVMContext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/LegacyPassManager.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Module.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Type.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Verifier.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Support/TargetSelect.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Target/TargetMachine.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Transforms/Scalar.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Transforms/Scalar/GVN.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../include/KaleidoscopeJIT.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm::orc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Lexer</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The lexer returns tokens [0-255] if it is an unknown character, otherwise one</span></span><br><span class="line"><span class="comment">// of these for known things.</span></span><br><span class="line"><span class="keyword">enum</span> Token &#123;</span><br><span class="line">  tok_eof = <span class="number">-1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// commands</span></span><br><span class="line">  tok_def = <span class="number">-2</span>,</span><br><span class="line">  tok_extern = <span class="number">-3</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// primary</span></span><br><span class="line">  tok_identifier = <span class="number">-4</span>,</span><br><span class="line">  tok_number = <span class="number">-5</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// control</span></span><br><span class="line">  tok_if = <span class="number">-6</span>,</span><br><span class="line">  tok_then = <span class="number">-7</span>,</span><br><span class="line">  tok_else = <span class="number">-8</span>,</span><br><span class="line">  tok_for = <span class="number">-9</span>,</span><br><span class="line">  tok_in = <span class="number">-10</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// operators</span></span><br><span class="line">  tok_binary = <span class="number">-11</span>,</span><br><span class="line">  tok_unary = <span class="number">-12</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> IdentifierStr; <span class="comment">// Filled in if tok_identifier</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> NumVal;             <span class="comment">// Filled in if tok_number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// gettok - Return the next token from standard input.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gettok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> LastChar = <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip any whitespace.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isspace</span>(LastChar))</span><br><span class="line">    LastChar = getchar();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isalpha</span>(LastChar)) &#123; <span class="comment">// identifier: [a-zA-Z][a-zA-Z0-9]*</span></span><br><span class="line">    IdentifierStr = LastChar;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalnum</span>((LastChar = getchar())))</span><br><span class="line">      IdentifierStr += LastChar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"def"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_def;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"extern"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_extern;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"if"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_if;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"then"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_then;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"else"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_else;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"for"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_for;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"in"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_in;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"binary"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_binary;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"unary"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_unary;</span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">'.'</span>) &#123; <span class="comment">// Number: [0-9.]+</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> NumStr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      NumStr += LastChar;</span><br><span class="line">      LastChar = getchar();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    NumVal = strtod(NumStr.c_str(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> tok_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (LastChar == <span class="string">'#'</span>) &#123;</span><br><span class="line">    <span class="comment">// Comment until end of line.</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      LastChar = getchar();</span><br><span class="line">    <span class="keyword">while</span> (LastChar != EOF &amp;&amp; LastChar != <span class="string">'\n'</span> &amp;&amp; LastChar != <span class="string">'\r'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LastChar != EOF)</span><br><span class="line">      <span class="keyword">return</span> gettok();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for end of file.  Don't eat the EOF.</span></span><br><span class="line">  <span class="keyword">if</span> (LastChar == EOF)</span><br><span class="line">    <span class="keyword">return</span> tok_eof;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, just return the character as its ascii value.</span></span><br><span class="line">  <span class="keyword">int</span> ThisChar = LastChar;</span><br><span class="line">  LastChar = getchar();</span><br><span class="line">  <span class="keyword">return</span> ThisChar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Abstract Syntax Tree (aka Parse Tree)</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprAST</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~ExprAST() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Value *<span class="title">codegen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NumberExprAST - Expression class for numeric literals like "1.0".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NumberExprAST(<span class="keyword">double</span> Val) : Val(Val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// VariableExprAST - Expression class for referencing a variable, like "a".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  VariableExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Name) : Name(Name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// UnaryExprAST - Expression class for a unary operator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnaryExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">char</span> Opcode;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Operand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  UnaryExprAST(<span class="keyword">char</span> Opcode, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Operand)</span><br><span class="line">      : Opcode(Opcode), Operand(<span class="built_in">std</span>::move(Operand)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinaryExprAST - Expression class for a binary operator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">char</span> Op;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS, RHS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  BinaryExprAST(<span class="keyword">char</span> Op, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS,</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; RHS)</span><br><span class="line">      : Op(Op), LHS(<span class="built_in">std</span>::move(LHS)), RHS(<span class="built_in">std</span>::move(RHS)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CallExprAST - Expression class for function calls.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Callee;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  CallExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Callee,</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args)</span><br><span class="line">      : Callee(Callee), Args(<span class="built_in">std</span>::move(Args)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// IfExprAST - Expression class for if/then/else.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IfExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Cond, Then, Else;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  IfExprAST(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Cond, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Then,</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Else)</span><br><span class="line">      : Cond(<span class="built_in">std</span>::move(Cond)), Then(<span class="built_in">std</span>::move(Then)), Else(<span class="built_in">std</span>::move(Else)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ForExprAST - Expression class for for/in.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> VarName;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Start, End, Step, Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ForExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;VarName, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Start,</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; End, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Step,</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body)</span><br><span class="line">      : VarName(VarName), Start(<span class="built_in">std</span>::move(Start)), End(<span class="built_in">std</span>::move(End)),</span><br><span class="line">        Step(<span class="built_in">std</span>::move(Step)), Body(<span class="built_in">std</span>::move(Body)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// PrototypeAST - This class represents the "prototype" for a function,</span></span><br><span class="line"><span class="comment">/// which captures its name, and its argument names (thus implicitly the number</span></span><br><span class="line"><span class="comment">/// of arguments the function takes), as well as if it is an operator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args;</span><br><span class="line">  <span class="keyword">bool</span> IsOperator;</span><br><span class="line">  <span class="keyword">unsigned</span> Precedence; <span class="comment">// Precedence if a binary op.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PrototypeAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Name, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args,</span><br><span class="line">               <span class="keyword">bool</span> IsOperator = <span class="literal">false</span>, <span class="keyword">unsigned</span> Prec = <span class="number">0</span>)</span><br><span class="line">      : Name(Name), Args(<span class="built_in">std</span>::move(Args)), IsOperator(IsOperator),</span><br><span class="line">        Precedence(Prec) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Function *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isUnaryOp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> IsOperator &amp;&amp; Args.size() == <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isBinaryOp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> IsOperator &amp;&amp; Args.size() == <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">getOperatorName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    assert(isUnaryOp() || isBinaryOp());</span><br><span class="line">    <span class="keyword">return</span> Name[Name.size() - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">getBinaryPrecedence</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Precedence; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// FunctionAST - This class represents a function definition itself.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  FunctionAST(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto,</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body)</span><br><span class="line">      : Proto(<span class="built_in">std</span>::move(Proto)), Body(<span class="built_in">std</span>::move(Body)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Function *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Parser</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current</span></span><br><span class="line"><span class="comment">/// token the parser is looking at.  getNextToken reads another token from the</span></span><br><span class="line"><span class="comment">/// lexer and updates CurTok with its results.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> CurTok;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextToken</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CurTok = gettok(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinopPrecedence - This holds the precedence for each binary operator that is</span></span><br><span class="line"><span class="comment">/// defined.</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; BinopPrecedence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// GetTokPrecedence - Get the precedence of the pending binary operator token.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetTokPrecedence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isascii(CurTok))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure it's a declared binop.</span></span><br><span class="line">  <span class="keyword">int</span> TokPrec = BinopPrecedence[CurTok];</span><br><span class="line">  <span class="keyword">if</span> (TokPrec &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> TokPrec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Error* - These are little helper functions for error handling.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LogError(<span class="keyword">const</span> <span class="keyword">char</span> *Str) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: %s\n"</span>, Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; LogErrorP(<span class="keyword">const</span> <span class="keyword">char</span> *Str) &#123;</span><br><span class="line">  LogError(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseExpression();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// numberexpr ::= number</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseNumberExpr() &#123;</span><br><span class="line">  <span class="keyword">auto</span> Result = llvm::make_unique&lt;NumberExprAST&gt;(NumVal);</span><br><span class="line">  getNextToken(); <span class="comment">// consume the number</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(Result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// parenexpr ::= '(' expression ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseParenExpr() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat (.</span></span><br><span class="line">  <span class="keyword">auto</span> V = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected ')'"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat ).</span></span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= identifier</span></span><br><span class="line"><span class="comment">///   ::= identifier '(' expression* ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseIdentifierExpr() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> IdName = IdentifierStr;</span><br><span class="line"></span><br><span class="line">  getNextToken(); <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>) <span class="comment">// Simple variable ref.</span></span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;VariableExprAST&gt;(IdName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call.</span></span><br><span class="line">  getNextToken(); <span class="comment">// eat (</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Arg = ParseExpression())</span><br><span class="line">        Args.push_back(<span class="built_in">std</span>::move(Arg));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok == <span class="string">')'</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok != <span class="string">','</span>)</span><br><span class="line">        <span class="keyword">return</span> LogError(<span class="string">"Expected ')' or ',' in argument list"</span>);</span><br><span class="line">      getNextToken();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eat the ')'.</span></span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;CallExprAST&gt;(IdName, <span class="built_in">std</span>::move(Args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ifexpr ::= 'if' expression 'then' expression 'else' expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseIfExpr() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat the if.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// condition.</span></span><br><span class="line">  <span class="keyword">auto</span> Cond = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!Cond)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_then)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected then"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat the then</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Then = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!Then)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_else)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected else"</span>);</span><br><span class="line"></span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Else = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!Else)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;IfExprAST&gt;(<span class="built_in">std</span>::move(Cond), <span class="built_in">std</span>::move(Then),</span><br><span class="line">                                      <span class="built_in">std</span>::move(Else));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseForExpr() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat the for.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected identifier after for"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> IdName = IdentifierStr;</span><br><span class="line">  getNextToken(); <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'='</span>)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected '=' after for"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat '='.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Start = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!Start)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">','</span>)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected ',' after for start value"</span>);</span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> End = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!End)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The step value is optional.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Step;</span><br><span class="line">  <span class="keyword">if</span> (CurTok == <span class="string">','</span>) &#123;</span><br><span class="line">    getNextToken();</span><br><span class="line">    Step = ParseExpression();</span><br><span class="line">    <span class="keyword">if</span> (!Step)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_in)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected 'in' after for"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat 'in'.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Body = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!Body)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;ForExprAST&gt;(IdName, <span class="built_in">std</span>::move(Start), <span class="built_in">std</span>::move(End),</span><br><span class="line">                                       <span class="built_in">std</span>::move(Step), <span class="built_in">std</span>::move(Body));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// primary</span></span><br><span class="line"><span class="comment">///   ::= identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= numberexpr</span></span><br><span class="line"><span class="comment">///   ::= parenexpr</span></span><br><span class="line"><span class="comment">///   ::= ifexpr</span></span><br><span class="line"><span class="comment">///   ::= forexpr</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParsePrimary() &#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"unknown token when expecting an expression"</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> ParseIdentifierExpr();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> ParseNumberExpr();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">    <span class="keyword">return</span> ParseParenExpr();</span><br><span class="line">  <span class="keyword">case</span> tok_if:</span><br><span class="line">    <span class="keyword">return</span> ParseIfExpr();</span><br><span class="line">  <span class="keyword">case</span> tok_for:</span><br><span class="line">    <span class="keyword">return</span> ParseForExpr();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// unary</span></span><br><span class="line"><span class="comment">///   ::= primary</span></span><br><span class="line"><span class="comment">///   ::= '!' unary</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseUnary() &#123;</span><br><span class="line">  <span class="comment">// If the current token is not an operator, it must be a primary expr.</span></span><br><span class="line">  <span class="keyword">if</span> (!isascii(CurTok) || CurTok == <span class="string">'('</span> || CurTok == <span class="string">','</span>)</span><br><span class="line">    <span class="keyword">return</span> ParsePrimary();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is a unary operator, read it.</span></span><br><span class="line">  <span class="keyword">int</span> Opc = CurTok;</span><br><span class="line">  getNextToken();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Operand = ParseUnary())</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;UnaryExprAST&gt;(Opc, <span class="built_in">std</span>::move(Operand));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// binoprhs</span></span><br><span class="line"><span class="comment">///   ::= ('+' unary)*</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseBinOpRHS(<span class="keyword">int</span> ExprPrec,</span><br><span class="line">                                              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS) &#123;</span><br><span class="line">  <span class="comment">// If this is a binop, find its precedence.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> TokPrec = GetTokPrecedence();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a binop that binds at least as tightly as the current binop,</span></span><br><span class="line">    <span class="comment">// consume it, otherwise we are done.</span></span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; ExprPrec)</span><br><span class="line">      <span class="keyword">return</span> LHS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Okay, we know this is a binop.</span></span><br><span class="line">    <span class="keyword">int</span> BinOp = CurTok;</span><br><span class="line">    getNextToken(); <span class="comment">// eat binop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the unary expression after the binary operator.</span></span><br><span class="line">    <span class="keyword">auto</span> RHS = ParseUnary();</span><br><span class="line">    <span class="keyword">if</span> (!RHS)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If BinOp binds less tightly with RHS than the operator after RHS, let</span></span><br><span class="line">    <span class="comment">// the pending operator take RHS as its LHS.</span></span><br><span class="line">    <span class="keyword">int</span> NextPrec = GetTokPrecedence();</span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; NextPrec) &#123;</span><br><span class="line">      RHS = ParseBinOpRHS(TokPrec + <span class="number">1</span>, <span class="built_in">std</span>::move(RHS));</span><br><span class="line">      <span class="keyword">if</span> (!RHS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge LHS/RHS.</span></span><br><span class="line">    LHS =</span><br><span class="line">        llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, <span class="built_in">std</span>::move(LHS), <span class="built_in">std</span>::move(RHS));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// expression</span></span><br><span class="line"><span class="comment">///   ::= unary binoprhs</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseExpression() &#123;</span><br><span class="line">  <span class="keyword">auto</span> LHS = ParseUnary();</span><br><span class="line">  <span class="keyword">if</span> (!LHS)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ParseBinOpRHS(<span class="number">0</span>, <span class="built_in">std</span>::move(LHS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///   ::= id '(' id* ')'</span></span><br><span class="line"><span class="comment">///   ::= binary LETTER number? (id, id)</span></span><br><span class="line"><span class="comment">///   ::= unary LETTER (id)</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParsePrototype() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> FnName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> Kind = <span class="number">0</span>; <span class="comment">// 0 = identifier, 1 = unary, 2 = binary.</span></span><br><span class="line">  <span class="keyword">unsigned</span> BinaryPrecedence = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected function name in prototype"</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    FnName = IdentifierStr;</span><br><span class="line">    Kind = <span class="number">0</span>;</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> tok_unary:</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">if</span> (!isascii(CurTok))</span><br><span class="line">      <span class="keyword">return</span> LogErrorP(<span class="string">"Expected unary operator"</span>);</span><br><span class="line">    FnName = <span class="string">"unary"</span>;</span><br><span class="line">    FnName += (<span class="keyword">char</span>)CurTok;</span><br><span class="line">    Kind = <span class="number">1</span>;</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> tok_binary:</span><br><span class="line">    getNextToken();</span><br><span class="line">    <span class="keyword">if</span> (!isascii(CurTok))</span><br><span class="line">      <span class="keyword">return</span> LogErrorP(<span class="string">"Expected binary operator"</span>);</span><br><span class="line">    FnName = <span class="string">"binary"</span>;</span><br><span class="line">    FnName += (<span class="keyword">char</span>)CurTok;</span><br><span class="line">    Kind = <span class="number">2</span>;</span><br><span class="line">    getNextToken();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the precedence if present.</span></span><br><span class="line">    <span class="keyword">if</span> (CurTok == tok_number) &#123;</span><br><span class="line">      <span class="keyword">if</span> (NumVal &lt; <span class="number">1</span> || NumVal &gt; <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">return</span> LogErrorP(<span class="string">"Invalid precedence: must be 1..100"</span>);</span><br><span class="line">      BinaryPrecedence = (<span class="keyword">unsigned</span>)NumVal;</span><br><span class="line">      getNextToken();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected '(' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ArgNames;</span><br><span class="line">  <span class="keyword">while</span> (getNextToken() == tok_identifier)</span><br><span class="line">    ArgNames.push_back(IdentifierStr);</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected ')' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// success.</span></span><br><span class="line">  getNextToken(); <span class="comment">// eat ')'.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Verify right number of names for operator.</span></span><br><span class="line">  <span class="keyword">if</span> (Kind &amp;&amp; ArgNames.size() != Kind)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Invalid number of operands for operator"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;PrototypeAST&gt;(FnName, ArgNames, Kind != <span class="number">0</span>,</span><br><span class="line">                                         BinaryPrecedence);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// definition ::= 'def' prototype expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; ParseDefinition() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat def.</span></span><br><span class="line">  <span class="keyword">auto</span> Proto = ParsePrototype();</span><br><span class="line">  <span class="keyword">if</span> (!Proto)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = ParseExpression())</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto), <span class="built_in">std</span>::move(E));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// toplevelexpr ::= expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; ParseTopLevelExpr() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = ParseExpression()) &#123;</span><br><span class="line">    <span class="comment">// Make an anonymous proto.</span></span><br><span class="line">    <span class="keyword">auto</span> Proto = llvm::make_unique&lt;PrototypeAST&gt;(<span class="string">"__anon_expr"</span>,</span><br><span class="line">                                                 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto), <span class="built_in">std</span>::move(E));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// external ::= 'extern' prototype</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParseExtern() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat extern.</span></span><br><span class="line">  <span class="keyword">return</span> ParsePrototype();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Code Generation</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> LLVMContext TheContext;</span><br><span class="line"><span class="keyword">static</span> IRBuilder&lt;&gt; Builder(TheContext);</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Module&gt; TheModule;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Value *&gt; NamedValues;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;legacy::FunctionPassManager&gt; TheFPM;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;KaleidoscopeJIT&gt; TheJIT;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt;&gt; FunctionProtos;</span><br><span class="line"></span><br><span class="line"><span class="function">Value *<span class="title">LogErrorV</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *Str)</span> </span>&#123;</span><br><span class="line">  LogError(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Function *<span class="title">getFunction</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> Name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// First, see if the function has already been added to the current module.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> *F = TheModule-&gt;getFunction(Name))</span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If not, check whether we can codegen the declaration from some existing</span></span><br><span class="line">  <span class="comment">// prototype.</span></span><br><span class="line">  <span class="keyword">auto</span> FI = FunctionProtos.find(Name);</span><br><span class="line">  <span class="keyword">if</span> (FI != FunctionProtos.end())</span><br><span class="line">    <span class="keyword">return</span> FI-&gt;second-&gt;codegen();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If no existing prototype exists, return null.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *NumberExprAST::codegen() &#123;</span><br><span class="line">  <span class="keyword">return</span> ConstantFP::get(TheContext, APFloat(Val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *VariableExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Look this variable up in the function.</span></span><br><span class="line">  Value *V = NamedValues[Name];</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown variable name"</span>);</span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *UnaryExprAST::codegen() &#123;</span><br><span class="line">  Value *OperandV = Operand-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!OperandV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  Function *F = getFunction(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"unary"</span>) + Opcode);</span><br><span class="line">  <span class="keyword">if</span> (!F)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown unary operator"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Builder.CreateCall(F, OperandV, <span class="string">"unop"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *BinaryExprAST::codegen() &#123;</span><br><span class="line">  Value *L = LHS-&gt;codegen();</span><br><span class="line">  Value *R = RHS-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFAdd(L, R, <span class="string">"addtmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFSub(L, R, <span class="string">"subtmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFMul(L, R, <span class="string">"multmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    L = Builder.CreateFCmpULT(L, R, <span class="string">"cmptmp"</span>);</span><br><span class="line">    <span class="comment">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class="line">    <span class="keyword">return</span> Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), <span class="string">"booltmp"</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If it wasn't a builtin binary operator, it must be a user defined one. Emit</span></span><br><span class="line">  <span class="comment">// a call to it.</span></span><br><span class="line">  Function *F = getFunction(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"binary"</span>) + Op);</span><br><span class="line">  assert(F &amp;&amp; <span class="string">"binary operator not found!"</span>);</span><br><span class="line"></span><br><span class="line">  Value *Ops[] = &#123;L, R&#125;;</span><br><span class="line">  <span class="keyword">return</span> Builder.CreateCall(F, Ops, <span class="string">"binop"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *CallExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Look up the name in the global module table.</span></span><br><span class="line">  Function *CalleeF = getFunction(Callee);</span><br><span class="line">  <span class="keyword">if</span> (!CalleeF)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown function referenced"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If argument mismatch error.</span></span><br><span class="line">  <span class="keyword">if</span> (CalleeF-&gt;arg_size() != Args.size())</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Incorrect # arguments passed"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Value *&gt; ArgsV;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, e = Args.size(); i != e; ++i) &#123;</span><br><span class="line">    ArgsV.push_back(Args[i]-&gt;codegen());</span><br><span class="line">    <span class="keyword">if</span> (!ArgsV.back())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Builder.CreateCall(CalleeF, ArgsV, <span class="string">"calltmp"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *IfExprAST::codegen() &#123;</span><br><span class="line">  Value *CondV = Cond-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!CondV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Convert condition to a bool by comparing non-equal to 0.0.</span></span><br><span class="line">  CondV = Builder.CreateFCmpONE(</span><br><span class="line">      CondV, ConstantFP::get(TheContext, APFloat(<span class="number">0.0</span>)), <span class="string">"ifcond"</span>);</span><br><span class="line"></span><br><span class="line">  Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create blocks for the then and else cases.  Insert the 'then' block at the</span></span><br><span class="line">  <span class="comment">// end of the function.</span></span><br><span class="line">  BasicBlock *ThenBB = BasicBlock::Create(TheContext, <span class="string">"then"</span>, TheFunction);</span><br><span class="line">  BasicBlock *ElseBB = BasicBlock::Create(TheContext, <span class="string">"else"</span>);</span><br><span class="line">  BasicBlock *MergeBB = BasicBlock::Create(TheContext, <span class="string">"ifcont"</span>);</span><br><span class="line"></span><br><span class="line">  Builder.CreateCondBr(CondV, ThenBB, ElseBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit then value.</span></span><br><span class="line">  Builder.SetInsertPoint(ThenBB);</span><br><span class="line"></span><br><span class="line">  Value *ThenV = Then-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!ThenV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  Builder.CreateBr(MergeBB);</span><br><span class="line">  <span class="comment">// Codegen of 'Then' can change the current block, update ThenBB for the PHI.</span></span><br><span class="line">  ThenBB = Builder.GetInsertBlock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit else block.</span></span><br><span class="line">  TheFunction-&gt;getBasicBlockList().push_back(ElseBB);</span><br><span class="line">  Builder.SetInsertPoint(ElseBB);</span><br><span class="line"></span><br><span class="line">  Value *ElseV = Else-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!ElseV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  Builder.CreateBr(MergeBB);</span><br><span class="line">  <span class="comment">// Codegen of 'Else' can change the current block, update ElseBB for the PHI.</span></span><br><span class="line">  ElseBB = Builder.GetInsertBlock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit merge block.</span></span><br><span class="line">  TheFunction-&gt;getBasicBlockList().push_back(MergeBB);</span><br><span class="line">  Builder.SetInsertPoint(MergeBB);</span><br><span class="line">  PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class="number">2</span>, <span class="string">"iftmp"</span>);</span><br><span class="line"></span><br><span class="line">  PN-&gt;addIncoming(ThenV, ThenBB);</span><br><span class="line">  PN-&gt;addIncoming(ElseV, ElseBB);</span><br><span class="line">  <span class="keyword">return</span> PN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output for-loop as:</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   start = startexpr</span></span><br><span class="line"><span class="comment">//   goto loop</span></span><br><span class="line"><span class="comment">// loop:</span></span><br><span class="line"><span class="comment">//   variable = phi [start, loopheader], [nextvariable, loopend]</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   bodyexpr</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">// loopend:</span></span><br><span class="line"><span class="comment">//   step = stepexpr</span></span><br><span class="line"><span class="comment">//   nextvariable = variable + step</span></span><br><span class="line"><span class="comment">//   endcond = endexpr</span></span><br><span class="line"><span class="comment">//   br endcond, loop, endloop</span></span><br><span class="line"><span class="comment">// outloop:</span></span><br><span class="line">Value *ForExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Emit the start code first, without 'variable' in scope.</span></span><br><span class="line">  Value *StartVal = Start-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!StartVal)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the new basic block for the loop header, inserting after current</span></span><br><span class="line">  <span class="comment">// block.</span></span><br><span class="line">  Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class="line">  BasicBlock *PreheaderBB = Builder.GetInsertBlock();</span><br><span class="line">  BasicBlock *LoopBB = BasicBlock::Create(TheContext, <span class="string">"loop"</span>, TheFunction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert an explicit fall through from the current block to the LoopBB.</span></span><br><span class="line">  Builder.CreateBr(LoopBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start insertion in LoopBB.</span></span><br><span class="line">  Builder.SetInsertPoint(LoopBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the PHI node with an entry for Start.</span></span><br><span class="line">  PHINode *Variable =</span><br><span class="line">      Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class="number">2</span>, VarName);</span><br><span class="line">  Variable-&gt;addIncoming(StartVal, PreheaderBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Within the loop, the variable is defined equal to the PHI node.  If it</span></span><br><span class="line">  <span class="comment">// shadows an existing variable, we have to restore it, so save it now.</span></span><br><span class="line">  Value *OldVal = NamedValues[VarName];</span><br><span class="line">  NamedValues[VarName] = Variable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit the body of the loop.  This, like any other expr, can change the</span></span><br><span class="line">  <span class="comment">// current BB.  Note that we ignore the value computed by the body, but don't</span></span><br><span class="line">  <span class="comment">// allow an error.</span></span><br><span class="line">  <span class="keyword">if</span> (!Body-&gt;codegen())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit the step value.</span></span><br><span class="line">  Value *StepVal = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (Step) &#123;</span><br><span class="line">    StepVal = Step-&gt;codegen();</span><br><span class="line">    <span class="keyword">if</span> (!StepVal)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If not specified, use 1.0.</span></span><br><span class="line">    StepVal = ConstantFP::get(TheContext, APFloat(<span class="number">1.0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Value *NextVar = Builder.CreateFAdd(Variable, StepVal, <span class="string">"nextvar"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the end condition.</span></span><br><span class="line">  Value *EndCond = End-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!EndCond)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Convert condition to a bool by comparing non-equal to 0.0.</span></span><br><span class="line">  EndCond = Builder.CreateFCmpONE(</span><br><span class="line">      EndCond, ConstantFP::get(TheContext, APFloat(<span class="number">0.0</span>)), <span class="string">"loopcond"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the "after loop" block and insert it.</span></span><br><span class="line">  BasicBlock *LoopEndBB = Builder.GetInsertBlock();</span><br><span class="line">  BasicBlock *AfterBB =</span><br><span class="line">      BasicBlock::Create(TheContext, <span class="string">"afterloop"</span>, TheFunction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert the conditional branch into the end of LoopEndBB.</span></span><br><span class="line">  Builder.CreateCondBr(EndCond, LoopBB, AfterBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Any new code will be inserted in AfterBB.</span></span><br><span class="line">  Builder.SetInsertPoint(AfterBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add a new entry to the PHI node for the backedge.</span></span><br><span class="line">  Variable-&gt;addIncoming(NextVar, LoopEndBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restore the unshadowed variable.</span></span><br><span class="line">  <span class="keyword">if</span> (OldVal)</span><br><span class="line">    NamedValues[VarName] = OldVal;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    NamedValues.erase(VarName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for expr always returns 0.0.</span></span><br><span class="line">  <span class="keyword">return</span> Constant::getNullValue(Type::getDoubleTy(TheContext));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function *PrototypeAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Make the function type:  double(double,double) etc.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type *&gt; Doubles(Args.size(), Type::getDoubleTy(TheContext));</span><br><span class="line">  FunctionType *FT =</span><br><span class="line">      FunctionType::get(Type::getDoubleTy(TheContext), Doubles, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  Function *F =</span><br><span class="line">      Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set names for all arguments.</span></span><br><span class="line">  <span class="keyword">unsigned</span> Idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : F-&gt;args())</span><br><span class="line">    Arg.setName(Args[Idx++]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function *FunctionAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Transfer ownership of the prototype to the FunctionProtos map, but keep a</span></span><br><span class="line">  <span class="comment">// reference to it for use below.</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;P = *Proto;</span><br><span class="line">  FunctionProtos[Proto-&gt;getName()] = <span class="built_in">std</span>::move(Proto);</span><br><span class="line">  Function *TheFunction = getFunction(P.getName());</span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is an operator, install it.</span></span><br><span class="line">  <span class="keyword">if</span> (P.isBinaryOp())</span><br><span class="line">    BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new basic block to start insertion into.</span></span><br><span class="line">  BasicBlock *BB = BasicBlock::Create(TheContext, <span class="string">"entry"</span>, TheFunction);</span><br><span class="line">  Builder.SetInsertPoint(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">  NamedValues.clear();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;args())</span><br><span class="line">    NamedValues[Arg.getName()] = &amp;Arg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Value *RetVal = Body-&gt;codegen()) &#123;</span><br><span class="line">    <span class="comment">// Finish off the function.</span></span><br><span class="line">    Builder.CreateRet(RetVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate the generated code, checking for consistency.</span></span><br><span class="line">    verifyFunction(*TheFunction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the optimizer on the function.</span></span><br><span class="line">    TheFPM-&gt;run(*TheFunction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TheFunction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Error reading body, remove function.</span></span><br><span class="line">  TheFunction-&gt;eraseFromParent();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (P.isBinaryOp())</span><br><span class="line">    BinopPrecedence.erase(P.getOperatorName());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Top-Level parsing and JIT Driver</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeModuleAndPassManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Open a new module.</span></span><br><span class="line">  TheModule = llvm::make_unique&lt;Module&gt;(<span class="string">"my cool jit"</span>, TheContext);</span><br><span class="line">  TheModule-&gt;setDataLayout(TheJIT-&gt;getTargetMachine().createDataLayout());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new pass manager attached to it.</span></span><br><span class="line">  TheFPM = llvm::make_unique&lt;legacy::FunctionPassManager&gt;(TheModule.get());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do simple "peephole" optimizations and bit-twiddling optzns.</span></span><br><span class="line">  TheFPM-&gt;add(createInstructionCombiningPass());</span><br><span class="line">  <span class="comment">// Reassociate expressions.</span></span><br><span class="line">  TheFPM-&gt;add(createReassociatePass());</span><br><span class="line">  <span class="comment">// Eliminate Common SubExpressions.</span></span><br><span class="line">  TheFPM-&gt;add(createGVNPass());</span><br><span class="line">  <span class="comment">// Simplify the control flow graph (deleting unreachable blocks, etc).</span></span><br><span class="line">  TheFPM-&gt;add(createCFGSimplificationPass());</span><br><span class="line"></span><br><span class="line">  TheFPM-&gt;doInitialization();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = ParseDefinition()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = FnAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read function definition:"</span>);</span><br><span class="line">      FnIR-&gt;print(errs());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">      TheJIT-&gt;addModule(<span class="built_in">std</span>::move(TheModule));</span><br><span class="line">      InitializeModuleAndPassManager();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> ProtoAST = ParseExtern()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = ProtoAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read extern: "</span>);</span><br><span class="line">      FnIR-&gt;print(errs());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">      FunctionProtos[ProtoAST-&gt;getName()] = <span class="built_in">std</span>::move(ProtoAST);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleTopLevelExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Evaluate a top-level expression into an anonymous function.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = ParseTopLevelExpr()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FnAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="comment">// JIT the module containing the anonymous expression, keeping a handle so</span></span><br><span class="line">      <span class="comment">// we can free it later.</span></span><br><span class="line">      <span class="keyword">auto</span> H = TheJIT-&gt;addModule(<span class="built_in">std</span>::move(TheModule));</span><br><span class="line">      InitializeModuleAndPassManager();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Search the JIT for the __anon_expr symbol.</span></span><br><span class="line">      <span class="keyword">auto</span> ExprSymbol = TheJIT-&gt;findSymbol(<span class="string">"__anon_expr"</span>);</span><br><span class="line">      assert(ExprSymbol &amp;&amp; <span class="string">"Function not found"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Get the symbol's address and cast it to the right type (takes no</span></span><br><span class="line">      <span class="comment">// arguments, returns a double) so we can call it as a native function.</span></span><br><span class="line">      <span class="keyword">double</span> (*FP)() = (<span class="keyword">double</span> (*)())(<span class="keyword">intptr_t</span>)cantFail(ExprSymbol.getAddress());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Evaluated to %f\n"</span>, FP());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Delete the anonymous expression module from the JIT.</span></span><br><span class="line">      TheJIT-&gt;removeModule(H);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// top ::= definition | external | expression | ';'</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ready&gt; "</span>);</span><br><span class="line">    <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">    <span class="keyword">case</span> tok_eof:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">';'</span>: <span class="comment">// ignore top-level semicolons.</span></span><br><span class="line">      getNextToken();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_def:</span><br><span class="line">      HandleDefinition();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_extern:</span><br><span class="line">      HandleExtern();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      HandleTopLevelExpression();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// "Library" functions that can be "extern'd" from user code.</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LLVM_ON_WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLEXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLEXPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// putchard - putchar that takes a double and returns 0.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">DLLEXPORT <span class="keyword">double</span> <span class="title">putchard</span><span class="params">(<span class="keyword">double</span> X)</span> </span>&#123;</span><br><span class="line">  fputc((<span class="keyword">char</span>)X, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// printd - printf that takes a double prints it as "%f\n", returning 0.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">DLLEXPORT <span class="keyword">double</span> <span class="title">printd</span><span class="params">(<span class="keyword">double</span> X)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%f\n"</span>, X);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Main driver code.</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  InitializeNativeTarget();</span><br><span class="line">  InitializeNativeTargetAsmPrinter();</span><br><span class="line">  InitializeNativeTargetAsmParser();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">'&lt;'</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'+'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'-'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'*'</span>] = <span class="number">40</span>; <span class="comment">// highest.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prime the first token.</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ready&gt; "</span>);</span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  TheJIT = llvm::make_unique&lt;KaleidoscopeJIT&gt;();</span><br><span class="line"></span><br><span class="line">  InitializeModuleAndPassManager();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the main "interpreter loop" now.</span></span><br><span class="line">  MainLoop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/12/6-Kaleidoscope-Extending-the-Language-User-defined-Operators/" data-id="cjciqlvvi000g3f5imje1cwod" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-Tutorial/">LLVM Tutorial</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/01/12/5-Kaleidoscope-Extending-the-Language-Control-Flow/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">5. Kaleidoscope: Extending the Language: Control Flow</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM-Tutorial/">LLVM Tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/LLVM-Tutorial/" style="font-size: 10px;">LLVM Tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/12/6-Kaleidoscope-Extending-the-Language-User-defined-Operators/">6. Kaleidoscope: Extending the Language: User-defined Operators</a>
          </li>
        
          <li>
            <a href="/2018/01/12/5-Kaleidoscope-Extending-the-Language-Control-Flow/">5. Kaleidoscope: Extending the Language: Control Flow</a>
          </li>
        
          <li>
            <a href="/2018/01/11/4-Kaleidoscope-Adding-JIT-and-Optimizer-Support/">4. Kaleidoscope: Adding JIT and Optimizer Support</a>
          </li>
        
          <li>
            <a href="/2018/01/11/3-Kaleidoscope-Code-generation-to-LLVM-IR/">3. Kaleidoscope: Code generation to LLVM IR</a>
          </li>
        
          <li>
            <a href="/2018/01/10/2-Kaleidoscope-Implementing-a-Parser-and-AST/">2. Kaleidoscope: Implementing a Parser and AST</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LiTong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>