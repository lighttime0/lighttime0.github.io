<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>4. Kaleidoscope: Adding JIT and Optimizer Support | LiTong&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="4.1. Chapter 4 Introduction欢迎来到“用LLVM实现一门编程语言”教程第4章。第1-3章描述了一个简单的编程语言的实现，并添加了生成LLVM IR的支持。这一章将会描述两个新技术：为你的语言增加优化支持，以及增加即使编译支持。这两个新增的技术将会展示如何获得Kaleidoscope语言的优雅、高效的代码。">
<meta name="keywords" content="LLVM Tutorial">
<meta property="og:type" content="article">
<meta property="og:title" content="4. Kaleidoscope: Adding JIT and Optimizer Support">
<meta property="og:url" content="http://yoursite.com/2018/01/11/4-Kaleidoscope-Adding-JIT-and-Optimizer-Support/index.html">
<meta property="og:site_name" content="LiTong&#39;s Blog">
<meta property="og:description" content="4.1. Chapter 4 Introduction欢迎来到“用LLVM实现一门编程语言”教程第4章。第1-3章描述了一个简单的编程语言的实现，并添加了生成LLVM IR的支持。这一章将会描述两个新技术：为你的语言增加优化支持，以及增加即使编译支持。这两个新增的技术将会展示如何获得Kaleidoscope语言的优雅、高效的代码。">
<meta property="og:locale" content="zh">
<meta property="og:updated_time" content="2018-01-11T13:27:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="4. Kaleidoscope: Adding JIT and Optimizer Support">
<meta name="twitter:description" content="4.1. Chapter 4 Introduction欢迎来到“用LLVM实现一门编程语言”教程第4章。第1-3章描述了一个简单的编程语言的实现，并添加了生成LLVM IR的支持。这一章将会描述两个新技术：为你的语言增加优化支持，以及增加即使编译支持。这两个新增的技术将会展示如何获得Kaleidoscope语言的优雅、高效的代码。">
  
    <link rel="alternate" href="/atom.xml" title="LiTong&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiTong&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-4-Kaleidoscope-Adding-JIT-and-Optimizer-Support" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/11/4-Kaleidoscope-Adding-JIT-and-Optimizer-Support/" class="article-date">
  <time datetime="2018-01-11T13:25:57.000Z" itemprop="datePublished">2018-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      4. Kaleidoscope: Adding JIT and Optimizer Support
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="4-1-Chapter-4-Introduction"><a href="#4-1-Chapter-4-Introduction" class="headerlink" title="4.1. Chapter 4 Introduction"></a>4.1. Chapter 4 Introduction</h2><p>欢迎来到“<a href="https://releases.llvm.org/5.0.0/docs/tutorial/index.html" target="_blank" rel="noopener">用LLVM实现一门编程语言</a>”教程第4章。第1-3章描述了一个简单的编程语言的实现，并添加了生成LLVM IR的支持。这一章将会描述两个新技术：为你的语言增加优化支持，以及增加即使编译支持。这两个新增的技术将会展示如何获得Kaleidoscope语言的优雅、高效的代码。</p>
<a id="more"></a>
<!-- Welcome to Chapter 4 of the “[Implementing a language with LLVM](https://releases.llvm.org/5.0.0/docs/tutorial/index.html)” tutorial. Chapters 1-3 described the implementation of a simple language and added support for generating LLVM IR. This chapter describes two new techniques: adding optimizer support to your language, and adding JIT compiler support. These additions will demonstrate how to get nice, efficient code for the Kaleidoscope language. -->
<h2 id="4-2-Trivial-Constant-Folding"><a href="#4-2-Trivial-Constant-Folding" class="headerlink" title="4.2. Trivial Constant Folding"></a>4.2. Trivial Constant Folding</h2><p>我们在第3章中的示范非常优雅，而且容易扩展。但是，它并没有生成完美的代码。IRBuild在编译这段简单的代码中只进行了最基本的优化。</p>
<!-- Our demonstration for Chapter 3 is elegant and easy to extend. Unfortunately, it does not produce wonderful code. The IRBuilder, however, does give us obvious optimizations when compiling simple code: -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def <span class="built_in">test</span>(x) 1+2+x;</span><br><span class="line">Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @<span class="built_in">test</span>(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">        %addtmp = fadd double 3.000000e+00, %x</span><br><span class="line">        ret double %addtmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码并不是对AST的直接翻译。对输入进行语法分析后生成的AST的直接翻译应该是下面这样：</p>
<!-- This code is not a literal transcription of the AST built by parsing the input. That would be: -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def <span class="built_in">test</span>(x) 1+2+x;</span><br><span class="line">Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @<span class="built_in">test</span>(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">        %addtmp = fadd double 2.000000e+00, 1.000000e+00</span><br><span class="line">        %addtmp1 = fadd double %addtmp, %x</span><br><span class="line">        ret double %addtmp1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量折叠（Constant folding），正如上面所见，是一种非常常见且重要的优化：很多编程语言的实现里都在它们的AST表示中包含了常量折叠的支持。</p>
<!-- Constant folding, as seen above, in particular, is a very common and very important optimization: so much so that many language implementors implement constant folding support in their AST representation. -->
<p>使用LLVM，你不需要在AST中增加这项支持。因为所有创建LLVM IR的调用都会经过LLVM IR builder，在你调用时，builder会检查是否有常量折叠的机会，如果有，它就会进行常量折叠，并且返回一个constant而不是创建一条instruction。</p>
<!-- With LLVM, you don’t need this support in the AST. Since all calls to build LLVM IR go through the LLVM IR builder, the builder itself checked to see if there was a constant folding opportunity when you call it. If so, it just does the constant fold and return the constant instead of creating an instruction. -->
<p>实际中，我们推荐在生成代码时，总应该使用<code>IRBuilder</code>。它没有“syntactic overhead”（你不需要在每个地方增加常量折叠检查，让你的编译器代码变得复杂），而且在某些情况下，它可以减少生成的LLVM IR的代码总量（尤其是对于有宏预处理或者使用大量constants的编程语言）。</p>
<!-- Well, that was easy :). In practice, we recommend always using `IRBuilder` when generating code like this. It has no “syntactic overhead” for its use (you don’t have to uglify your compiler with constant checks everywhere) and it can dramatically reduce the amount of LLVM IR that is generated in some cases (particular for languages with a macro preprocessor or that use a lot of constants). -->
<p>另一方面，<code>IRBuilder</code>的能力也有局限，它只在它要构造的代码内部做分析和优化。如果你用一个稍微复杂一点的例子：</p>
<!-- On the other hand, the `IRBuilder` is limited by the fact that it does all of its analysis inline with the code as it is built. If you take a slightly more complex example: -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def <span class="built_in">test</span>(x) (1+2+x)*(x+(1+2));</span><br><span class="line">ready&gt; Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @<span class="built_in">test</span>(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">        %addtmp = fadd double 3.000000e+00, %x</span><br><span class="line">        %addtmp1 = fadd double %x, 3.000000e+00</span><br><span class="line">        %multmp = fmul double %addtmp, %addtmp1</span><br><span class="line">        ret double %multmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的情况中，乘法的LHS和RHS是相同的值。我们希望可以生成“<code>tmp = x+3; result = tmp*tmp;</code>”，而不是两次计算“<code>x+3</code>”。</p>
<!-- In this case, the LHS and RHS of the multiplication are the same value. We’d really like to see this generate “`tmp = x+3; result = tmp*tmp;`” instead of computing “`x+3`” twice. -->
<p>不幸的是，没有哪个局部分析可以检测并优化这种情况。这种优化需要两次转换：表达式的重组（让加法在词法分析层面完全相同），以及消除公共子表达式（CSE）来检测冗余的加法指令。幸运的是，LLVM提供了大量的优化，以“passes”的形式。</p>
<!-- Unfortunately, no amount of local analysis will be able to detect and correct this. This requires two transformations: reassociation of expressions (to make the add’s lexically identical) and Common Subexpression Elimination (CSE) to delete the redundant add instruction. Fortunately, LLVM provides a broad range of optimizations that you can use, in the form of “passes”. -->
<h2 id="4-3-LLVM-Optimization-Passes"><a href="#4-3-LLVM-Optimization-Passes" class="headerlink" title="4.3. LLVM Optimization Passes"></a>4.3. LLVM Optimization Passes</h2><p>LLVM提供了很多优化passes，可以做很多种事情，提供多种tradeoffs。和其他的系统不同，LLVM摒弃了一套优化可以处理所有语言和所有情况的错误观念。LLVM允许编译器实现者完全决定做哪些优化，用什么顺序优化，以及在哪些情形下做优化。</p>
<!--LLVM provides many optimization passes, which do many different sorts of things and have different tradeoffs. Unlike other systems, LLVM doesn’t hold to the mistaken notion that one set of optimizations is right for all languages and for all situations. LLVM allows a compiler implementor to make complete decisions about what optimizations to use, in which order, and in what situation.-->
<p>LLVM支持“whole module” passes，也支持“per-function” passes。“whole module” passes会对全部代码尽可能的做分析（通常是一个完整的文件，但如果在link时做分析，可能只能分析完整程序的一部分）。“per-function” passes一次只对一个函数进行分析。更多关于pass以及pass如何运行的信息，参见<a href="https://releases.llvm.org/5.0.0/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">How to Write a Pass</a>文档，以及<a href="https://releases.llvm.org/5.0.0/docs/Passes.html" target="_blank" rel="noopener">List of LLVM Passes</a>。</p>
<!-- As a concrete example, LLVM supports both “whole module” passes, which look across as large of body of code as they can (often a whole file, but if run at link time, this can be a substantial portion of the whole program). It also supports and includes “per-function” passes which just operate on a single function at a time, without looking at other functions. For more information on passes and how they are run, see the [How to Write a Pass](https://releases.llvm.org/5.0.0/docs/WritingAnLLVMPass.html) document and the [List of LLVM Passes](https://releases.llvm.org/5.0.0/docs/Passes.html). -->
<p>对Kaleidoscope来说，我们现在是用户输入后，动态地生成函数，每次生成一个。这里我们并没有追求完美的优化体验，但我们也会在可能的情况下让事情简单快速。这样一来，我们将会选择运行一些per-function优化，在用户输入function之后。如果我们想制作一个“静态Kaleidoscope编译器”，我们将会使用我们现在已有的代码，但是我们会将优化步骤推迟到对全部文件进行语法分析完成之后。</p>
<!-- For Kaleidoscope, we are currently generating functions on the fly, one at a time, as the user types them in. We aren’t shooting for the ultimate optimization experience in this setting, but we also want to catch the easy and quick stuff where possible. As such, we will choose to run a few per-function optimizations as the user types the function in. If we wanted to make a “static Kaleidoscope compiler”, we would use exactly the code we have now, except that we would defer running the optimizer until the entire file has been parsed. -->
<p>为了执行per-function优化，我们需要安装<a href="https://releases.llvm.org/5.0.0/docs/WritingAnLLVMPass.html#what-passmanager-doesr" target="_blank" rel="noopener">FunctionPassManager</a>来管理我们想运行的LLVM优化器。当我们设置好后，就可以增加一系列的优化器。对每个想要优化的module，都需要增加一个新的FunctionPassManager，所以我们写了一个函数去创建并初始化module和pass manager：</p>
<!-- In order to get per-function optimizations going, we need to set up a [FunctionPassManager](https://releases.llvm.org/5.0.0/docs/WritingAnLLVMPass.html#what-passmanager-doesr) to hold and organize the LLVM optimizations that we want to run. Once we have that, we can add a set of optimizations to run. We’ll need a new FunctionPassManager for each module that we want to optimize, so we’ll write a function to create and initialize both the module and pass manager for us: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeModuleAndPassManager</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Open a new module.</span></span><br><span class="line">  TheModule = llvm::make_unique&lt;Module&gt;(<span class="string">"my cool jit"</span>, TheContext);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new pass manager attached to it.</span></span><br><span class="line">  TheFPM = llvm::make_unique&lt;FunctionPassManager&gt;(TheModule.get());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do simple "peephole" optimizations and bit-twiddling optzns.</span></span><br><span class="line">  TheFPM-&gt;add(createInstructionCombiningPass());</span><br><span class="line">  <span class="comment">// Reassociate expressions.</span></span><br><span class="line">  TheFPM-&gt;add(createReassociatePass());</span><br><span class="line">  <span class="comment">// Eliminate Common SubExpressions.</span></span><br><span class="line">  TheFPM-&gt;add(createGVNPass());</span><br><span class="line">  <span class="comment">// Simplify the control flow graph (deleting unreachable blocks, etc).</span></span><br><span class="line">  TheFPM-&gt;add(createCFGSimplificationPass());</span><br><span class="line"></span><br><span class="line">  TheFPM-&gt;doInitialization();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码初始化了一个全局的module <code>TheModule</code>，以及一个function pass manager <code>TheFPM</code>，并连接到<code>TheModule</code>。当pass manager设置好后，我们用了一系列的”add“调用来增加一系列的LLVM passes。</p>
<!-- This code initializes the global module `TheModule`, and the function pass manager `TheFPM`, which is attached to `TheModule`. Once the pass manager is set up, we use a series of “add” calls to add a bunch of LLVM passes. -->
<p>在这个情况下，我们选择添加四个优化passes。我们选择的passes是一组比较标准的”cleanup“优化，对很多代码都有用。我们不会深入探讨它们做了什么，但是相信我，它们是一个很好的起点。</p>
<!-- In this case, we choose to add four optimization passes. The passes we choose here are a pretty standard set of “cleanup” optimizations that are useful for a wide variety of code. I won’t delve into what they do but, believe me, they are a good starting place :). -->
<p>当PassManager设置好后，我们需要使用它。这一步运行在新创建的函数构造好（通过in <code>FunctionAST::codegen()</code>）之后，返回给用户之前。</p>
<!-- Once the PassManager is set up, we need to make use of it. We do this by running it after our newly created function is constructed (in `FunctionAST::codegen()`), but before it is returned to the client: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Value *RetVal = Body-&gt;codegen()) &#123;</span><br><span class="line">  <span class="comment">// Finish off the function.</span></span><br><span class="line">  Builder.CreateRet(RetVal);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate the generated code, checking for consistency.</span></span><br><span class="line">  verifyFunction(*TheFunction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optimize the function.</span></span><br><span class="line">  TheFPM-&gt;run(*TheFunction);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TheFunction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所见，这一切都很直观。<code>FunctionPassManager</code>在合适的地方优化并更新了LLVM Fucntion*，（可能）改进了函数体。这时，我们可以重新试验一下之前的代码：</p>
<!-- As you can see, this is pretty straightforward. The `FunctionPassManager` optimizes and updates the LLVM Function\* in place, improving (hopefully) its body. With this in place, we can try our test above again: -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def <span class="built_in">test</span>(x) (1+2+x)*(x+(1+2));</span><br><span class="line">ready&gt; Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @<span class="built_in">test</span>(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">        %addtmp = fadd double %x, 3.000000e+00</span><br><span class="line">        %multmp = fmul double %addtmp, %addtmp</span><br><span class="line">        ret double %multmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如所期望的样子，我们现在获得了优化后的代码，优化后这个函数每次执行时都可以节省一条浮点加法指令。</p>
<!-- As expected, we now get our nicely optimized code, saving a floating point add instruction from every execution of this function. -->
<p>LLVM提供了很多种类的优化，可以在不同的情境中使用。你可以参考一些<a href="https://releases.llvm.org/5.0.0/docs/Passes.html" target="_blank" rel="noopener">documentation about the various passes</a>，但它们并不很完整。另一个ideas的好来源是从看<code>Clang</code>运行哪些passes开始。“<code>opt</code>”工具允许你在命令行中试验passes，这样你就可以看出它们是否让代码做出某些改变。</p>
<!-- LLVM provides a wide variety of optimizations that can be used in certain circumstances. Some [documentation about the various passes](https://releases.llvm.org/5.0.0/docs/Passes.html) is available, but it isn’t very complete. Another good source of ideas can come from looking at the passes that `Clang` runs to get started. The “`opt`” tool allows you to experiment with passes from the command line, so you can see if they do anything. -->
<p>现在从我们的前端生成了不错的代码，让我们开始讨论如何运行他们！</p>
<!-- Now that we have reasonable code coming out of our front-end, lets talk about executing it! -->
<h2 id="4-4-Adding-a-JIT-Compiler"><a href="#4-4-Adding-a-JIT-Compiler" class="headerlink" title="4.4. Adding a JIT Compiler"></a>4.4. Adding a JIT Compiler</h2><p>有很多种类的工具可以应用在LLVM IR上。比如说，你可以运行优化器（就像上面做的那样），可以dump out成文本或者二进制格式，可以编译成某些平台上的汇编文件（.s），也可以即时编译。LLVM IR的好处就在于它是一种编译器不同部分之间的“通用格式”。</p>
<!-- Code that is available in LLVM IR can have a wide variety of tools applied to it. For example, you can run optimizations on it (as we did above), you can dump it out in textual or binary forms, you can compile the code to an assembly file (.s) for some target, or you can JIT compile it. The nice thing about the LLVM IR representation is that it is the “common currency” between many different parts of the compiler. -->
<p>在这一节中，我们将为我们的解释器增加即时编译支持。基本思路是用户输入函数体时和当前一样，但是输入顶层表达式时，立即计算出表达式的值。比如说，如果用户输入“1+2”，我们应该计算并输出3。如果用户定义了一个函数，用户应该可以从命令行调用这个函数。</p>
<!-- In this section, we’ll add JIT compiler support to our interpreter. The basic idea that we want for Kaleidoscope is to have the user enter function bodies as they do now, but immediately evaluate the top-level expressions they type in. For example, if they type in “1 + 2;”, we should evaluate and print out 3. If they define a function, they should be able to call it from the command line. -->
<p>为此，我们首先需要为本机准备创建代码的环境，创建并初始化JIT。这一步可以通过调用一些<code>InitializeNativeTarget\*</code>函数，并添加一个全局变量<code>TheJIT</code>，然后在<code>main</code>中初始化：</p>
<!-- In order to do this, we first prepare the environment to create code for the current native target and declare and initialize the JIT. This is done by calling some `InitializeNativeTarget\*` functions and adding a global variable `TheJIT`, and initializing it in `main`: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;KaleidoscopeJIT&gt; TheJIT;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  InitializeNativeTarget();</span><br><span class="line">  InitializeNativeTargetAsmPrinter();</span><br><span class="line">  InitializeNativeTargetAsmParser();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">'&lt;'</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'+'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'-'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'*'</span>] = <span class="number">40</span>; <span class="comment">// highest.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prime the first token.</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ready&gt; "</span>);</span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  TheJIT = llvm::make_unique&lt;KaleidoscopeJIT&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the main "interpreter loop" now.</span></span><br><span class="line">  MainLoop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还需要设置JIT的data layout：</p>
<!-- We also need to setup the data layout for the JIT: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeModuleAndPassManager</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Open a new module.</span></span><br><span class="line">  TheModule = llvm::make_unique&lt;Module&gt;(<span class="string">"my cool jit"</span>, TheContext);</span><br><span class="line">  TheModule-&gt;setDataLayout(TheJIT-&gt;getTargetMachine().createDataLayout());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new pass manager attached to it.</span></span><br><span class="line">  TheFPM = llvm::make_unique&lt;FunctionPassManager&gt;(TheModule.get());</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>KaleidoscopeJIT类是为这些教程设计的一个简单的JIT，包含在LLVM源代码中，位于llvm-src/examples/Kaleidoscope/include/KaleidoscopeJIT.h。在后面的章节里我们将会展示它是如何工作的，并扩展出新特性，但是现在我们只是使用它。它的API非常简单：<code>addModule</code>为JIT增加一个LLVM IR module，让它的函数可以执行；<code>removeModule</code>移除一个module，释放那个module中的所有内存；<code>findSymbol</code>让我们可以找到编译后代码的pointers。</p>
<!-- The KaleidoscopeJIT class is a simple JIT built specifically for these tutorials, available inside the LLVM source code at llvm-src/examples/Kaleidoscope/include/KaleidoscopeJIT.h. In later chapters we will look at how it works and extend it with new features, but for now we will take it as given. Its API is very simple: `addModule` adds an LLVM IR module to the JIT, making its functions available for execution; `removeModule` removes a module, freeing any memory associated with the code in that module; and `findSymbol` allows us to look up pointers to the compiled code. -->
<p>我们可以使用这些简单的API，改变我们的代码，对顶层表达式进行语法分析如下：</p>
<!-- We can take this simple API and change our code that parses top-level expressions to look like this:  --> 
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleTopLevelExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Evaluate a top-level expression into an anonymous function.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = ParseTopLevelExpr()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FnAST-&gt;codegen()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// JIT the module containing the anonymous expression, keeping a handle so</span></span><br><span class="line">      <span class="comment">// we can free it later.</span></span><br><span class="line">      <span class="keyword">auto</span> H = TheJIT-&gt;addModule(<span class="built_in">std</span>::move(TheModule));</span><br><span class="line">      InitializeModuleAndPassManager();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Search the JIT for the __anon_expr symbol.</span></span><br><span class="line">      <span class="keyword">auto</span> ExprSymbol = TheJIT-&gt;findSymbol(<span class="string">"__anon_expr"</span>);</span><br><span class="line">      assert(ExprSymbol &amp;&amp; <span class="string">"Function not found"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Get the symbol's address and cast it to the right type (takes no</span></span><br><span class="line">      <span class="comment">// arguments, returns a double) so we can call it as a native function.</span></span><br><span class="line">      <span class="keyword">double</span> (*FP)() = (<span class="keyword">double</span> (*)())(<span class="keyword">intptr_t</span>)ExprSymbol.getAddress();</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Evaluated to %f\n"</span>, FP());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Delete the anonymous expression module from the JIT.</span></span><br><span class="line">      TheJIT-&gt;removeModule(H);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果语法分析和codegen成功，下一步就是在JIT中添加包含顶层表达式的module。我们通过调用addModule来完成这件事，它会为这个module中所有函数进行代码生成，并且返回一个句柄，这个句柄将会在后面从JIT中删除module时用到。当module添加到JIT后，就不能再修改了，所以我们通过调用<code>InitializeModuleAndPassManager()</code>创建了一个新的module保存后面的代码。</p>
<!-- If parsing and codegen succeeed, the next step is to add the module containing the top-level expression to the JIT. We do this by calling addModule, which triggers code generation for all the functions in the module, and returns a handle that can be used to remove the module from the JIT later. Once the module has been added to the JIT it can no longer be modified, so we also open a new module to hold subsequent code by calling `InitializeModuleAndPassManager()`. -->
<p>当我们向JIT添加module后，我们需要获取指向最终生成的代码的指针。我们通过调用JIT的findSymbol方法来做这件事，并且传递顶层表达式函数的名字：<code>__anon_expr</code>。因为我们只添加了一个函数，我们在findSymbol返回结果后添加了一个assert。</p>
<!-- Once we’ve added the module to the JIT we need to get a pointer to the final generated code. We do this by calling the JIT’s findSymbol method, and passing the name of the top-level expression function: `__anon_expr`. Since we just added this function, we assert that findSymbol returned a result. -->
<p>下面，我们通过在symbol上调用<code>getAddress()</code>获得<code>__anon_expr</code>函数的内存地址。之前我们将顶层表达式编译成为一个LLVM函数，不接受任何参数，返回double型的表达式的计算结果。因为LLVM JIT编译器匹配了本地硬件平台应用程序二进制接口（ABI），这意味着你可以you can just cast the result pointer to a function pointer of that type and call it directly。这样一来，JIT编译得到的代码和静态链接到你的程序的本机代码就没有区别了。</p>
<!-- Next, we get the in-memory address of the `__anon_expr` function by calling `getAddress()` on the symbol. Recall that we compile top-level expressions into a self-contained LLVM function that takes no arguments and returns the computed double. Because the LLVM JIT compiler matches the native platform ABI, this means that you can just cast the result pointer to a function pointer of that type and call it directly. This means, there is no difference between JIT compiled code and native machine code that is statically linked into your application. -->
<p>最后，因为我们不支持顶层表达式的重新计算，在计算完后，我们会将module从JIT移除，并释放相关的内存。但是，要记得，我们在几行前创建的module（通过<code>InitializeModuleAndPassManager</code>建立的）仍然存在，并等待新代码。</p>
<!-- Finally, since we don’t support re-evaluation of top-level expressions, we remove the module from the JIT when we’re done to free the associated memory. Recall, however, that the module we created a few lines earlier (via `InitializeModuleAndPassManager`) is still open and waiting for new code to be added. -->
<p>添加了这两个改变后，让我们看看Kaleidoscope现在是怎样工作的！</p>
<!-- With just these two changes, lets see how Kaleidoscope works now! -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; 4+5;</span><br><span class="line">Read top-level expression:</span><br><span class="line">define double @<span class="function">0</span>() &#123;</span><br><span class="line">entry:</span><br><span class="line">  ret double 9.000000e+00</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Evaluated to 9.000000</span><br></pre></td></tr></table></figure>
<p>现在看起来基本能工作了。函数的dump显示“no argument function that always returns double”</p>
<p>Well this looks like it is basically working. The dump of the function shows the “no argument function that always returns double” that we synthesize for each top-level expression that is typed in. This demonstrates very basic functionality, but can we do more?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def testfunc(x y) x + y*2;</span><br><span class="line">Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @testfunc(double %x, double %y) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %multmp = fmul double %y, 2.000000e+00</span><br><span class="line">  %addtmp = fadd double %multmp, %x</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ready&gt; testfunc(4, 10);</span><br><span class="line">Read top-level expression:</span><br><span class="line">define double @<span class="function">1</span>() &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call double @testfunc(double 4.000000e+00, double 1.000000e+01)</span><br><span class="line">  ret double %calltmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Evaluated to 24.000000</span><br><span class="line"></span><br><span class="line">ready&gt; testfunc(5, 10);</span><br><span class="line">ready&gt; LLVM ERROR: Program used external <span class="keyword">function</span> <span class="string">'testfunc'</span> <span class="built_in">which</span> could not be resolved!</span><br></pre></td></tr></table></figure>
<p>函数定义和调用也都成功了，但是最后一行有一个ERROR。这个调用看起来是合法的，到底发生了什么呢？可能你已经从API中猜到了，一个module是JIT分配的一个单元，testfunc是这个module的一部分，包含了一个匿名表达式。当我们从JIT中移除了这个module，并且释放了这个匿名表达式的内存后，我们同时也删除了testfunc的定义。然后，当我们试着第二次调用<code>testfunc</code>时，JIT就找不到它了。</p>
<!-- Function definitions and calls also work, but something went very wrong on that last line. The call looks valid, so what happened? As you may have guessed from the the API a Module is a unit of allocation for the JIT, and testfunc was part of the same module that contained anonymous expression. When we removed that module from the JIT to free the memory for the anonymous expression, we deleted the definition of testfunc along with it. Then, when we tried to call `testfunc` a second time, the JIT could no longer find it. -->
<p>解决这个ERROR最简单的办法是将这个匿名表达式放在一个和其他函数定义分开的单独的module中。JIT可以很轻松的处理跨module的函数调用，只要每个被调用的函数都有函数原型，并且在被调用前添加到JIT中。将匿名表达式放在一个不同的module中，我们可以在不影响其他函数的情况下删除它。</p>
<!-- The easiest way to fix this is to put the anonymous expression in a separate module from the rest of the function definitions. The JIT will happily resolve function calls across module boundaries, as long as each of the functions called has a prototype, and is added to the JIT before it is called. By putting the anonymous expression in a different module we can delete it without affecting the rest of the functions. -->
<p>实际上，进一步我们将把每一个函数放到一个单独的module中。这样做可以为KaleidoscopeJIT开发出一个有用的特性，让我们的环境更像一个交互式解释器环境（REPL）：函数可以被多次添加到JIT（不像一个module中所有函数的定义都不能相同）。当你在KaleidoscopeJIT中查找一个symbol时，它总会返回最新的定义：</p>
<!-- In fact, we’re going to go a step further and put every function in its own module. Doing so allows us to exploit a useful property of the KaleidoscopeJIT that will make our environment more REPL-like: Functions can be added to the JIT more than once (unlike a module where every function must have a unique definition). When you look up a symbol in KaleidoscopeJIT it will always return the most recent definition: -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def foo(x) x + 1;</span><br><span class="line">Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @foo(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd double %x, 1.000000e+00</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ready&gt; foo(2);</span><br><span class="line">Evaluated to 3.000000</span><br><span class="line"></span><br><span class="line">ready&gt; def foo(x) x + 2;</span><br><span class="line">define double @foo(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd double %x, 2.000000e+00</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ready&gt; foo(2);</span><br><span class="line">Evaluated to 4.000000</span><br></pre></td></tr></table></figure>
<p>为了允许每个函数都能保存在单独的module中，我们需要在每个打开的新module中重新创建之前函数的声明。</p>
<!-- To allow each function to live in its own module we’ll need a way to re-generate previous function declarations into each new module we open: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;KaleidoscopeJIT&gt; TheJIT;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">Function *<span class="title">getFunction</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> Name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// First, see if the function has already been added to the current module.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> *F = TheModule-&gt;getFunction(Name))</span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If not, check whether we can codegen the declaration from some existing</span></span><br><span class="line">  <span class="comment">// prototype.</span></span><br><span class="line">  <span class="keyword">auto</span> FI = FunctionProtos.find(Name);</span><br><span class="line">  <span class="keyword">if</span> (FI != FunctionProtos.end())</span><br><span class="line">    <span class="keyword">return</span> FI-&gt;second-&gt;codegen();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If no existing prototype exists, return null.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Value *CallExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Look up the name in the global module table.</span></span><br><span class="line">  Function *CalleeF = getFunction(Callee);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Function *FunctionAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Transfer ownership of the prototype to the FunctionProtos map, but keep a</span></span><br><span class="line">  <span class="comment">// reference to it for use below.</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;P = *Proto;</span><br><span class="line">  FunctionProtos[Proto-&gt;getName()] = <span class="built_in">std</span>::move(Proto);</span><br><span class="line">  Function *TheFunction = getFunction(P.getName());</span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>为此，我们首先要增加一个新的全局变量<code>FunctionProtos</code>，它保存了每个函数的最新的函数原型。为了方便实用，我们将增加一个新的方法<code>getFunction()</code>，来代替<code>TheModule-&gt;getFunction()</code>的调用。这个新方法会在<code>TheModule</code>中搜索已经存在的函数声明，如果没有找到的话，会从FunctionProtos中生成一个新的声明。在<code>CallExprAST::codegen()</code>中，我们只需要替换<code>TheModule-&gt;getFunction()</code>。在<code>FunctionAST::codegen()</code>中，我们首先需要更新FunctionProtos map，然后调用<code>getFunction()</code>。这些做完之后，我们就可以在当前module中获取任意之前声明的函数的函数声明了。</p>
<!-- To enable this, we’ll start by adding a new global, `FunctionProtos`, that holds the most recent prototype for each function. We’ll also add a convenience method, `getFunction()`, to replace calls to `TheModule->getFunction()`. Our convenience method searches `TheModule` for an existing function declaration, falling back to generating a new declaration from FunctionProtos if it doesn’t find one. In `CallExprAST::codegen()` we just need to replace the call to `TheModule->getFunction()`. In `FunctionAST::codegen()` we need to update the FunctionProtos map first, then call `getFunction()`. With this done, we can always obtain a function declaration in the current module for any previously declared function. -->
<p>我们还需要更新HandleDefinition和HandleExtern：</p>
<!-- We also need to update HandleDefinition and HandleExtern: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = ParseDefinition()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = FnAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read function definition:"</span>);</span><br><span class="line">      FnIR-&gt;print(errs());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">      TheJIT-&gt;addModule(<span class="built_in">std</span>::move(TheModule));</span><br><span class="line">      InitializeModuleAndPassManager();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">     getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> ProtoAST = ParseExtern()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = ProtoAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read extern: "</span>);</span><br><span class="line">      FnIR-&gt;print(errs());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">      FunctionProtos[ProtoAST-&gt;getName()] = <span class="built_in">std</span>::move(ProtoAST);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在HandleDefinition中，我们增加了两行，将新定义的函数转移到JIT中，并打开一个新的module。在HandleExtern中，我们只增加了一行，将函数原型添加到FunctionProtos中。</p>
<!-- In HandleDefinition, we add two lines to transfer the newly defined function to the JIT and open a new module. In HandleExtern, we just need to add one line to add the prototype to FunctionProtos. -->
<p>这些做完后，让我们再试一次我们的交互式解释器环境（REPL）（这次我们没有显示匿名函数的dump，你应该可以自己想到结果）：</p>
<!-- With these changes made, lets try our REPL again (I removed the dump of the anonymous functions this time, you should get the idea by now :) : -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def foo(x) x + 1;</span><br><span class="line">ready&gt; foo(2);</span><br><span class="line">Evaluated to 3.000000</span><br><span class="line"></span><br><span class="line">ready&gt; def foo(x) x + 2;</span><br><span class="line">ready&gt; foo(2);</span><br><span class="line">Evaluated to 4.000000</span><br></pre></td></tr></table></figure>
<p>成功了！</p>
<!-- It works! -->
<p>即使是这样简单的代码，我们也可以获得令人惊讶的强大的处理能力，试试这些例子：</p>
<!-- Even with this simple code, we get some surprisingly powerful capabilities - check this out: -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; extern sin(x);</span><br><span class="line">Read extern:</span><br><span class="line"><span class="built_in">declare</span> double @sin(double)</span><br><span class="line"></span><br><span class="line">ready&gt; extern cos(x);</span><br><span class="line">Read extern:</span><br><span class="line"><span class="built_in">declare</span> double @cos(double)</span><br><span class="line"></span><br><span class="line">ready&gt; sin(1.0);</span><br><span class="line">Read top-level expression:</span><br><span class="line">define double @<span class="function">2</span>() &#123;</span><br><span class="line">entry:</span><br><span class="line">  ret double 0x3FEAED548F090CEE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Evaluated to 0.841471</span><br><span class="line"></span><br><span class="line">ready&gt; def foo(x) sin(x)*sin(x) + cos(x)*cos(x);</span><br><span class="line">Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @foo(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call double @sin(double %x)</span><br><span class="line">  %multmp = fmul double %calltmp, %calltmp</span><br><span class="line">  %calltmp2 = call double @cos(double %x)</span><br><span class="line">  %multmp4 = fmul double %calltmp2, %calltmp2</span><br><span class="line">  %addtmp = fadd double %multmp, %multmp4</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ready&gt; foo(4.0);</span><br><span class="line">Read top-level expression:</span><br><span class="line">define double @<span class="function">3</span>() &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call double @foo(double 4.000000e+00)</span><br><span class="line">  ret double %calltmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Evaluated to 1.000000</span><br></pre></td></tr></table></figure>
<p>哇哦，JIT是怎么知道sin和cos的呢？答案惊人的简单：KaleidoscopeJIT有一个直观的，用来寻找不在任何module中symbol的规则：首先，在添加到JIT的所有module中搜索，按从最新到最旧的顺序，找最新的定义。如果在JIT中没找到，会在Kaleidoscope进程调用“<code>dlsym(&quot;sin&quot;)</code>”。因为“<code>sin</code>”在JIT的地址空间被定义，it simply patches up calls in the module to call the libm version of <code>sin</code> directly. But in some cases this even goes further: as sin and cos are names of standard math functions, the constant folder will directly evaluate the function calls to the correct result when called with constants like in the “<code>sin(1.0)</code>” above.</p>
<!-- Whoa, how does the JIT know about sin and cos? The answer is surprisingly simple: The KaleidoscopeJIT has a straightforward symbol resolution rule that it uses to find symbols that aren’t available in any given module: First it searches all the modules that have already been added to the JIT, from the most recent to the oldest, to find the newest definition. If no definition is found inside the JIT, it falls back to calling “`dlsym("sin")`” on the Kaleidoscope process itself. Since “`sin`” is defined within the JIT’s address space, it simply patches up calls in the module to call the libm version of `sin` directly. But in some cases this even goes further: as sin and cos are names of standard math functions, the constant folder will directly evaluate the function calls to the correct result when called with constants like in the “`sin(1.0)`” above. -->
<p>未来我们将会看到如何对这些symbol处理规则进行微调，生成各种有用的特性，从安全型（限制JIT编译的代码中，可访问的symbol集合），到基于symbol名的动态代码生成，甚至lazy编译。</p>
<!-- In the future we’ll see how tweaking this symbol resolution rule can be used to enable all sorts of useful features, from security (restricting the set of symbols available to JIT’d code), to dynamic code generation based on symbol names, and even lazy compilation. -->
<p>symbol resolution rule最直接的一个好处是我们现在可以通过编写C++代码来实现运算符，扩展这门语言。举例来说，如果我们添加：</p>
<!-- One immediate benefit of the symbol resolution rule is that we can now extend the language by writing arbitrary C++ code to implement operations. For example, if we add: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LLVM_ON_WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLEXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLEXPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// putchard - putchar that takes a double and returns 0.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">DLLEXPORT <span class="keyword">double</span> <span class="title">putchard</span><span class="params">(<span class="keyword">double</span> X)</span> </span>&#123;</span><br><span class="line">  fputc((<span class="keyword">char</span>)X, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在Windows系统中，我们需要实际地导出函数，因为动态符号加载器将使用GetProcAddress来查找symbols。</p>
<!-- Note, that for Windows we need to actually export the functions because the dynamic symbol loader will use GetProcAddress to find the symbols. -->
<p>现在我们可以用类似“<code>extern putchard(x); putchard(120);</code>”的语句来向控制台做简单的输出了，这条语句会在控制台打印一个小写的‘x’（120是‘x’的ASCII码）。相似的代码可以用来实现文件I/O，控制台输入，以及Kaleidoscope的许多其它功能。</p>
<!-- Now we can produce simple output to the console by using things like: “`extern putchard(x); putchard(120);`”, which prints a lowercase ‘x’ on the console (120 is the ASCII code for ‘x’). Similar code could be used to implement file I/O, console input, and many other capabilities in Kaleidoscope. -->
<p>至此，Kaleidoscope教程的JIT和优化器章节就结束了。现在，我们可以编译一门非图灵完备（non-Turing-complete）的编程语言，优化并在用户驱动下即时编译它。下面我们将进入<a href="https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl05.html" target="_blank" rel="noopener">extending the language with control flow constructs</a>，在探索的过程中解决LLVM IR的一些有趣的问题。</p>
<!-- This completes the JIT and optimizer chapter of the Kaleidoscope tutorial. At this point, we can compile a non-Turing-complete programming language, optimize and JIT compile it in a user-driven way. Next up we’ll look into [extending the language with control flow constructs](https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl05.html), tackling some interesting LLVM IR issues along the way. -->
<h2 id="4-5-Full-Code-Listing"><a href="#4-5-Full-Code-Listing" class="headerlink" title="4.5. Full Code Listing"></a>4.5. Full Code Listing</h2><p>这里是我们的例子的完整的，增加了LLVM JIT和优化器之后的代码。用下面的指令build这个例子：</p>
<!-- Here is the complete code listing for our running example, enhanced with the LLVM JIT and optimizer. To build this example, use: -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compile</span></span><br><span class="line">clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native` -O3 -o toy</span><br><span class="line"><span class="comment"># Run</span></span><br><span class="line">./toy</span><br></pre></td></tr></table></figure>
<p>如果你在Linux系统下编译，请额外添加了“-rdynamic”选项。这个选项可以确保在运行时，外部函数被正确处理。</p>
<!-- If you are compiling this on Linux, make sure to add the “-rdynamic” option as well. This makes sure that the external functions are resolved properly at runtime. -->
<p>下面是代码：</p>
<!--Here is the code:-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/ADT/APFloat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/ADT/STLExtras.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/BasicBlock.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/DerivedTypes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Function.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/IRBuilder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/LLVMContext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/LegacyPassManager.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Module.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Type.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Verifier.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Support/TargetSelect.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Target/TargetMachine.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Transforms/Scalar.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Transforms/Scalar/GVN.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../include/KaleidoscopeJIT.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm::orc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Lexer</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The lexer returns tokens [0-255] if it is an unknown character, otherwise one</span></span><br><span class="line"><span class="comment">// of these for known things.</span></span><br><span class="line"><span class="keyword">enum</span> Token &#123;</span><br><span class="line">  tok_eof = <span class="number">-1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// commands</span></span><br><span class="line">  tok_def = <span class="number">-2</span>,</span><br><span class="line">  tok_extern = <span class="number">-3</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// primary</span></span><br><span class="line">  tok_identifier = <span class="number">-4</span>,</span><br><span class="line">  tok_number = <span class="number">-5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> IdentifierStr; <span class="comment">// Filled in if tok_identifier</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> NumVal;             <span class="comment">// Filled in if tok_number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// gettok - Return the next token from standard input.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gettok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> LastChar = <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip any whitespace.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isspace</span>(LastChar))</span><br><span class="line">    LastChar = getchar();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isalpha</span>(LastChar)) &#123; <span class="comment">// identifier: [a-zA-Z][a-zA-Z0-9]*</span></span><br><span class="line">    IdentifierStr = LastChar;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalnum</span>((LastChar = getchar())))</span><br><span class="line">      IdentifierStr += LastChar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"def"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_def;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"extern"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_extern;</span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">'.'</span>) &#123; <span class="comment">// Number: [0-9.]+</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> NumStr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      NumStr += LastChar;</span><br><span class="line">      LastChar = getchar();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    NumVal = strtod(NumStr.c_str(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> tok_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (LastChar == <span class="string">'#'</span>) &#123;</span><br><span class="line">    <span class="comment">// Comment until end of line.</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      LastChar = getchar();</span><br><span class="line">    <span class="keyword">while</span> (LastChar != EOF &amp;&amp; LastChar != <span class="string">'\n'</span> &amp;&amp; LastChar != <span class="string">'\r'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LastChar != EOF)</span><br><span class="line">      <span class="keyword">return</span> gettok();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for end of file.  Don't eat the EOF.</span></span><br><span class="line">  <span class="keyword">if</span> (LastChar == EOF)</span><br><span class="line">    <span class="keyword">return</span> tok_eof;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, just return the character as its ascii value.</span></span><br><span class="line">  <span class="keyword">int</span> ThisChar = LastChar;</span><br><span class="line">  LastChar = getchar();</span><br><span class="line">  <span class="keyword">return</span> ThisChar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Abstract Syntax Tree (aka Parse Tree)</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprAST</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~ExprAST() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Value *<span class="title">codegen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NumberExprAST - Expression class for numeric literals like "1.0".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NumberExprAST(<span class="keyword">double</span> Val) : Val(Val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// VariableExprAST - Expression class for referencing a variable, like "a".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  VariableExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Name) : Name(Name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinaryExprAST - Expression class for a binary operator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">char</span> Op;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS, RHS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  BinaryExprAST(<span class="keyword">char</span> Op, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS,</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; RHS)</span><br><span class="line">      : Op(Op), LHS(<span class="built_in">std</span>::move(LHS)), RHS(<span class="built_in">std</span>::move(RHS)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CallExprAST - Expression class for function calls.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Callee;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  CallExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Callee,</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args)</span><br><span class="line">      : Callee(Callee), Args(<span class="built_in">std</span>::move(Args)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// PrototypeAST - This class represents the "prototype" for a function,</span></span><br><span class="line"><span class="comment">/// which captures its name, and its argument names (thus implicitly the number</span></span><br><span class="line"><span class="comment">/// of arguments the function takes).</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PrototypeAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Name, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args)</span><br><span class="line">      : Name(Name), Args(<span class="built_in">std</span>::move(Args)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Function *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// FunctionAST - This class represents a function definition itself.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  FunctionAST(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto,</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body)</span><br><span class="line">      : Proto(<span class="built_in">std</span>::move(Proto)), Body(<span class="built_in">std</span>::move(Body)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Function *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Parser</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current</span></span><br><span class="line"><span class="comment">/// token the parser is looking at.  getNextToken reads another token from the</span></span><br><span class="line"><span class="comment">/// lexer and updates CurTok with its results.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> CurTok;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextToken</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CurTok = gettok(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinopPrecedence - This holds the precedence for each binary operator that is</span></span><br><span class="line"><span class="comment">/// defined.</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; BinopPrecedence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// GetTokPrecedence - Get the precedence of the pending binary operator token.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetTokPrecedence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isascii(CurTok))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure it's a declared binop.</span></span><br><span class="line">  <span class="keyword">int</span> TokPrec = BinopPrecedence[CurTok];</span><br><span class="line">  <span class="keyword">if</span> (TokPrec &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> TokPrec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// LogError* - These are little helper functions for error handling.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LogError(<span class="keyword">const</span> <span class="keyword">char</span> *Str) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: %s\n"</span>, Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; LogErrorP(<span class="keyword">const</span> <span class="keyword">char</span> *Str) &#123;</span><br><span class="line">  LogError(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseExpression();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// numberexpr ::= number</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseNumberExpr() &#123;</span><br><span class="line">  <span class="keyword">auto</span> Result = llvm::make_unique&lt;NumberExprAST&gt;(NumVal);</span><br><span class="line">  getNextToken(); <span class="comment">// consume the number</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(Result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// parenexpr ::= '(' expression ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseParenExpr() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat (.</span></span><br><span class="line">  <span class="keyword">auto</span> V = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected ')'"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat ).</span></span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= identifier</span></span><br><span class="line"><span class="comment">///   ::= identifier '(' expression* ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseIdentifierExpr() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> IdName = IdentifierStr;</span><br><span class="line"></span><br><span class="line">  getNextToken(); <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>) <span class="comment">// Simple variable ref.</span></span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;VariableExprAST&gt;(IdName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call.</span></span><br><span class="line">  getNextToken(); <span class="comment">// eat (</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Arg = ParseExpression())</span><br><span class="line">        Args.push_back(<span class="built_in">std</span>::move(Arg));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok == <span class="string">')'</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok != <span class="string">','</span>)</span><br><span class="line">        <span class="keyword">return</span> LogError(<span class="string">"Expected ')' or ',' in argument list"</span>);</span><br><span class="line">      getNextToken();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eat the ')'.</span></span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;CallExprAST&gt;(IdName, <span class="built_in">std</span>::move(Args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// primary</span></span><br><span class="line"><span class="comment">///   ::= identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= numberexpr</span></span><br><span class="line"><span class="comment">///   ::= parenexpr</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParsePrimary() &#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"unknown token when expecting an expression"</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> ParseIdentifierExpr();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> ParseNumberExpr();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">    <span class="keyword">return</span> ParseParenExpr();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// binoprhs</span></span><br><span class="line"><span class="comment">///   ::= ('+' primary)*</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseBinOpRHS(<span class="keyword">int</span> ExprPrec,</span><br><span class="line">                                              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS) &#123;</span><br><span class="line">  <span class="comment">// If this is a binop, find its precedence.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> TokPrec = GetTokPrecedence();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a binop that binds at least as tightly as the current binop,</span></span><br><span class="line">    <span class="comment">// consume it, otherwise we are done.</span></span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; ExprPrec)</span><br><span class="line">      <span class="keyword">return</span> LHS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Okay, we know this is a binop.</span></span><br><span class="line">    <span class="keyword">int</span> BinOp = CurTok;</span><br><span class="line">    getNextToken(); <span class="comment">// eat binop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the primary expression after the binary operator.</span></span><br><span class="line">    <span class="keyword">auto</span> RHS = ParsePrimary();</span><br><span class="line">    <span class="keyword">if</span> (!RHS)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If BinOp binds less tightly with RHS than the operator after RHS, let</span></span><br><span class="line">    <span class="comment">// the pending operator take RHS as its LHS.</span></span><br><span class="line">    <span class="keyword">int</span> NextPrec = GetTokPrecedence();</span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; NextPrec) &#123;</span><br><span class="line">      RHS = ParseBinOpRHS(TokPrec + <span class="number">1</span>, <span class="built_in">std</span>::move(RHS));</span><br><span class="line">      <span class="keyword">if</span> (!RHS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge LHS/RHS.</span></span><br><span class="line">    LHS =</span><br><span class="line">        llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, <span class="built_in">std</span>::move(LHS), <span class="built_in">std</span>::move(RHS));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// expression</span></span><br><span class="line"><span class="comment">///   ::= primary binoprhs</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseExpression() &#123;</span><br><span class="line">  <span class="keyword">auto</span> LHS = ParsePrimary();</span><br><span class="line">  <span class="keyword">if</span> (!LHS)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ParseBinOpRHS(<span class="number">0</span>, <span class="built_in">std</span>::move(LHS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///   ::= id '(' id* ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParsePrototype() &#123;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected function name in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> FnName = IdentifierStr;</span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected '(' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ArgNames;</span><br><span class="line">  <span class="keyword">while</span> (getNextToken() == tok_identifier)</span><br><span class="line">    ArgNames.push_back(IdentifierStr);</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected ')' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// success.</span></span><br><span class="line">  getNextToken(); <span class="comment">// eat ')'.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;PrototypeAST&gt;(FnName, <span class="built_in">std</span>::move(ArgNames));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// definition ::= 'def' prototype expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; ParseDefinition() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat def.</span></span><br><span class="line">  <span class="keyword">auto</span> Proto = ParsePrototype();</span><br><span class="line">  <span class="keyword">if</span> (!Proto)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = ParseExpression())</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto), <span class="built_in">std</span>::move(E));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// toplevelexpr ::= expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; ParseTopLevelExpr() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = ParseExpression()) &#123;</span><br><span class="line">    <span class="comment">// Make an anonymous proto.</span></span><br><span class="line">    <span class="keyword">auto</span> Proto = llvm::make_unique&lt;PrototypeAST&gt;(<span class="string">"__anon_expr"</span>,</span><br><span class="line">                                                 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto), <span class="built_in">std</span>::move(E));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// external ::= 'extern' prototype</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParseExtern() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat extern.</span></span><br><span class="line">  <span class="keyword">return</span> ParsePrototype();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Code Generation</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> LLVMContext TheContext;</span><br><span class="line"><span class="keyword">static</span> IRBuilder&lt;&gt; Builder(TheContext);</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Module&gt; TheModule;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Value *&gt; NamedValues;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;legacy::FunctionPassManager&gt; TheFPM;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;KaleidoscopeJIT&gt; TheJIT;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt;&gt; FunctionProtos;</span><br><span class="line"></span><br><span class="line"><span class="function">Value *<span class="title">LogErrorV</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *Str)</span> </span>&#123;</span><br><span class="line">  LogError(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Function *<span class="title">getFunction</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> Name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// First, see if the function has already been added to the current module.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> *F = TheModule-&gt;getFunction(Name))</span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If not, check whether we can codegen the declaration from some existing</span></span><br><span class="line">  <span class="comment">// prototype.</span></span><br><span class="line">  <span class="keyword">auto</span> FI = FunctionProtos.find(Name);</span><br><span class="line">  <span class="keyword">if</span> (FI != FunctionProtos.end())</span><br><span class="line">    <span class="keyword">return</span> FI-&gt;second-&gt;codegen();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If no existing prototype exists, return null.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *NumberExprAST::codegen() &#123;</span><br><span class="line">  <span class="keyword">return</span> ConstantFP::get(TheContext, APFloat(Val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *VariableExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Look this variable up in the function.</span></span><br><span class="line">  Value *V = NamedValues[Name];</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown variable name"</span>);</span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *BinaryExprAST::codegen() &#123;</span><br><span class="line">  Value *L = LHS-&gt;codegen();</span><br><span class="line">  Value *R = RHS-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFAdd(L, R, <span class="string">"addtmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFSub(L, R, <span class="string">"subtmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFMul(L, R, <span class="string">"multmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    L = Builder.CreateFCmpULT(L, R, <span class="string">"cmptmp"</span>);</span><br><span class="line">    <span class="comment">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class="line">    <span class="keyword">return</span> Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), <span class="string">"booltmp"</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"invalid binary operator"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *CallExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Look up the name in the global module table.</span></span><br><span class="line">  Function *CalleeF = getFunction(Callee);</span><br><span class="line">  <span class="keyword">if</span> (!CalleeF)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown function referenced"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If argument mismatch error.</span></span><br><span class="line">  <span class="keyword">if</span> (CalleeF-&gt;arg_size() != Args.size())</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Incorrect # arguments passed"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Value *&gt; ArgsV;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, e = Args.size(); i != e; ++i) &#123;</span><br><span class="line">    ArgsV.push_back(Args[i]-&gt;codegen());</span><br><span class="line">    <span class="keyword">if</span> (!ArgsV.back())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Builder.CreateCall(CalleeF, ArgsV, <span class="string">"calltmp"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function *PrototypeAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Make the function type:  double(double,double) etc.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type *&gt; Doubles(Args.size(), Type::getDoubleTy(TheContext));</span><br><span class="line">  FunctionType *FT =</span><br><span class="line">      FunctionType::get(Type::getDoubleTy(TheContext), Doubles, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  Function *F =</span><br><span class="line">      Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set names for all arguments.</span></span><br><span class="line">  <span class="keyword">unsigned</span> Idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : F-&gt;args())</span><br><span class="line">    Arg.setName(Args[Idx++]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function *FunctionAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Transfer ownership of the prototype to the FunctionProtos map, but keep a</span></span><br><span class="line">  <span class="comment">// reference to it for use below.</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;P = *Proto;</span><br><span class="line">  FunctionProtos[Proto-&gt;getName()] = <span class="built_in">std</span>::move(Proto);</span><br><span class="line">  Function *TheFunction = getFunction(P.getName());</span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new basic block to start insertion into.</span></span><br><span class="line">  BasicBlock *BB = BasicBlock::Create(TheContext, <span class="string">"entry"</span>, TheFunction);</span><br><span class="line">  Builder.SetInsertPoint(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">  NamedValues.clear();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;args())</span><br><span class="line">    NamedValues[Arg.getName()] = &amp;Arg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Value *RetVal = Body-&gt;codegen()) &#123;</span><br><span class="line">    <span class="comment">// Finish off the function.</span></span><br><span class="line">    Builder.CreateRet(RetVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate the generated code, checking for consistency.</span></span><br><span class="line">    verifyFunction(*TheFunction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the optimizer on the function.</span></span><br><span class="line">    TheFPM-&gt;run(*TheFunction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TheFunction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Error reading body, remove function.</span></span><br><span class="line">  TheFunction-&gt;eraseFromParent();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Top-Level parsing and JIT Driver</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeModuleAndPassManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Open a new module.</span></span><br><span class="line">  TheModule = llvm::make_unique&lt;Module&gt;(<span class="string">"my cool jit"</span>, TheContext);</span><br><span class="line">  TheModule-&gt;setDataLayout(TheJIT-&gt;getTargetMachine().createDataLayout());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new pass manager attached to it.</span></span><br><span class="line">  TheFPM = llvm::make_unique&lt;legacy::FunctionPassManager&gt;(TheModule.get());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do simple "peephole" optimizations and bit-twiddling optzns.</span></span><br><span class="line">  TheFPM-&gt;add(createInstructionCombiningPass());</span><br><span class="line">  <span class="comment">// Reassociate expressions.</span></span><br><span class="line">  TheFPM-&gt;add(createReassociatePass());</span><br><span class="line">  <span class="comment">// Eliminate Common SubExpressions.</span></span><br><span class="line">  TheFPM-&gt;add(createGVNPass());</span><br><span class="line">  <span class="comment">// Simplify the control flow graph (deleting unreachable blocks, etc).</span></span><br><span class="line">  TheFPM-&gt;add(createCFGSimplificationPass());</span><br><span class="line"></span><br><span class="line">  TheFPM-&gt;doInitialization();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = ParseDefinition()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = FnAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read function definition:"</span>);</span><br><span class="line">      FnIR-&gt;print(errs());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">      TheJIT-&gt;addModule(<span class="built_in">std</span>::move(TheModule));</span><br><span class="line">      InitializeModuleAndPassManager();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> ProtoAST = ParseExtern()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = ProtoAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read extern: "</span>);</span><br><span class="line">      FnIR-&gt;print(errs());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">      FunctionProtos[ProtoAST-&gt;getName()] = <span class="built_in">std</span>::move(ProtoAST);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleTopLevelExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Evaluate a top-level expression into an anonymous function.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = ParseTopLevelExpr()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FnAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="comment">// JIT the module containing the anonymous expression, keeping a handle so</span></span><br><span class="line">      <span class="comment">// we can free it later.</span></span><br><span class="line">      <span class="keyword">auto</span> H = TheJIT-&gt;addModule(<span class="built_in">std</span>::move(TheModule));</span><br><span class="line">      InitializeModuleAndPassManager();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Search the JIT for the __anon_expr symbol.</span></span><br><span class="line">      <span class="keyword">auto</span> ExprSymbol = TheJIT-&gt;findSymbol(<span class="string">"__anon_expr"</span>);</span><br><span class="line">      assert(ExprSymbol &amp;&amp; <span class="string">"Function not found"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Get the symbol's address and cast it to the right type (takes no</span></span><br><span class="line">      <span class="comment">// arguments, returns a double) so we can call it as a native function.</span></span><br><span class="line">      <span class="keyword">double</span> (*FP)() = (<span class="keyword">double</span> (*)())(<span class="keyword">intptr_t</span>)cantFail(ExprSymbol.getAddress());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Evaluated to %f\n"</span>, FP());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Delete the anonymous expression module from the JIT.</span></span><br><span class="line">      TheJIT-&gt;removeModule(H);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// top ::= definition | external | expression | ';'</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ready&gt; "</span>);</span><br><span class="line">    <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">    <span class="keyword">case</span> tok_eof:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">';'</span>: <span class="comment">// ignore top-level semicolons.</span></span><br><span class="line">      getNextToken();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_def:</span><br><span class="line">      HandleDefinition();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_extern:</span><br><span class="line">      HandleExtern();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      HandleTopLevelExpression();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// "Library" functions that can be "extern'd" from user code.</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LLVM_ON_WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLEXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLEXPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// putchard - putchar that takes a double and returns 0.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">DLLEXPORT <span class="keyword">double</span> <span class="title">putchard</span><span class="params">(<span class="keyword">double</span> X)</span> </span>&#123;</span><br><span class="line">  fputc((<span class="keyword">char</span>)X, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// printd - printf that takes a double prints it as "%f\n", returning 0.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">DLLEXPORT <span class="keyword">double</span> <span class="title">printd</span><span class="params">(<span class="keyword">double</span> X)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%f\n"</span>, X);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Main driver code.</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  InitializeNativeTarget();</span><br><span class="line">  InitializeNativeTargetAsmPrinter();</span><br><span class="line">  InitializeNativeTargetAsmParser();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">'&lt;'</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'+'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'-'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'*'</span>] = <span class="number">40</span>; <span class="comment">// highest.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prime the first token.</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ready&gt; "</span>);</span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  TheJIT = llvm::make_unique&lt;KaleidoscopeJIT&gt;();</span><br><span class="line"></span><br><span class="line">  InitializeModuleAndPassManager();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the main "interpreter loop" now.</span></span><br><span class="line">  MainLoop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/11/4-Kaleidoscope-Adding-JIT-and-Optimizer-Support/" data-id="cjciqjja1000a205i10qflx6x" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-Tutorial/">LLVM Tutorial</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/01/12/5-Kaleidoscope-Extending-the-Language-Control-Flow/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          5. Kaleidoscope: Extending the Language: Control Flow
        
      </div>
    </a>
  
  
    <a href="/2018/01/11/3-Kaleidoscope-Code-generation-to-LLVM-IR/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">3. Kaleidoscope: Code generation to LLVM IR</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM-Tutorial/">LLVM Tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/LLVM-Tutorial/" style="font-size: 10px;">LLVM Tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/17/8-Kaleidoscope-Compiling-to-Object-Code/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/01/12/6-Kaleidoscope-Extending-the-Language-User-defined-Operators/">6. Kaleidoscope: Extending the Language: User-defined Operators</a>
          </li>
        
          <li>
            <a href="/2018/01/12/5-Kaleidoscope-Extending-the-Language-Control-Flow/">5. Kaleidoscope: Extending the Language: Control Flow</a>
          </li>
        
          <li>
            <a href="/2018/01/11/4-Kaleidoscope-Adding-JIT-and-Optimizer-Support/">4. Kaleidoscope: Adding JIT and Optimizer Support</a>
          </li>
        
          <li>
            <a href="/2018/01/11/3-Kaleidoscope-Code-generation-to-LLVM-IR/">3. Kaleidoscope: Code generation to LLVM IR</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LiTong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>