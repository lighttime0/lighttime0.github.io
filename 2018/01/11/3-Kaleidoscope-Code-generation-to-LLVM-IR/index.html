<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>3. Kaleidoscope: Code generation to LLVM IR | LiTong&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="3.1. Chapter 3 Introduction欢迎来到用LLVM实现一门编程语言教程第3章。这一章将会为你展示如何把第2章介绍的抽象语法树转变为LLVM IR。这些内容会教给你一些LLVM做事情的方法，并向你展示LLVM非常易用。相比于生成LLVM IR code，构造词法分析器和语法分析器的工作量大很多。">
<meta name="keywords" content="LLVM Tutorial">
<meta property="og:type" content="article">
<meta property="og:title" content="3. Kaleidoscope: Code generation to LLVM IR">
<meta property="og:url" content="http://yoursite.com/2018/01/11/3-Kaleidoscope-Code-generation-to-LLVM-IR/index.html">
<meta property="og:site_name" content="LiTong&#39;s Blog">
<meta property="og:description" content="3.1. Chapter 3 Introduction欢迎来到用LLVM实现一门编程语言教程第3章。这一章将会为你展示如何把第2章介绍的抽象语法树转变为LLVM IR。这些内容会教给你一些LLVM做事情的方法，并向你展示LLVM非常易用。相比于生成LLVM IR code，构造词法分析器和语法分析器的工作量大很多。">
<meta property="og:locale" content="zh">
<meta property="og:updated_time" content="2018-01-11T07:03:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="3. Kaleidoscope: Code generation to LLVM IR">
<meta name="twitter:description" content="3.1. Chapter 3 Introduction欢迎来到用LLVM实现一门编程语言教程第3章。这一章将会为你展示如何把第2章介绍的抽象语法树转变为LLVM IR。这些内容会教给你一些LLVM做事情的方法，并向你展示LLVM非常易用。相比于生成LLVM IR code，构造词法分析器和语法分析器的工作量大很多。">
  
    <link rel="alternate" href="/atom.xml" title="LiTong&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiTong&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-3-Kaleidoscope-Code-generation-to-LLVM-IR" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/11/3-Kaleidoscope-Code-generation-to-LLVM-IR/" class="article-date">
  <time datetime="2018-01-11T03:34:44.000Z" itemprop="datePublished">2018-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      3. Kaleidoscope: Code generation to LLVM IR
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="3-1-Chapter-3-Introduction"><a href="#3-1-Chapter-3-Introduction" class="headerlink" title="3.1. Chapter 3 Introduction"></a>3.1. Chapter 3 Introduction</h2><p>欢迎来到<a href="https://releases.llvm.org/5.0.0/docs/tutorial/index.html" target="_blank" rel="noopener">用LLVM实现一门编程语言</a>教程第3章。这一章将会为你展示如何把第2章介绍的<a href="https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl02.html" target="_blank" rel="noopener">抽象语法树</a>转变为LLVM IR。这些内容会教给你一些LLVM做事情的方法，并向你展示LLVM非常易用。相比于生成LLVM IR code，构造词法分析器和语法分析器的工作量大很多。</p>
<a id="more"></a>
<!-- Welcome to Chapter 3 of the “[Implementing a language with LLVM](https://releases.llvm.org/5.0.0/docs/tutorial/index.html)” tutorial. This chapter shows you how to transform the [Abstract Syntax Tree](https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl02.html), built in Chapter 2, into LLVM IR. This will teach you a little bit about how LLVM does things, as well as demonstrate how easy it is to use. It’s much more work to build a lexer and parser than it is to generate LLVM IR code.-->
<p><strong>注意</strong>：这一章的代码需要LLVM 3.7或者更高版本，LLVM 3.6以及更低版本的不能运行这一章的代码。同时，你需要使用和你的LLVM版本对应的教程版本，如果你在使用官方的LLVM release，请使用在你的release中包含的文档，或者在<a href="http://llvm.org/releases/" target="_blank" rel="noopener">llvm.org releases page</a>寻找对应的文档。</p>
<!-- **Please note**: the code in this chapter and later require LLVM 3.7 or later. LLVM 3.6 and before will not work with it. Also note that you need to use a version of this tutorial that matches your LLVM release: If you are using an official LLVM release, use the version of the documentation included with your release or on the [llvm.org releases page](http://llvm.org/releases/). -->
<h2 id="3-2-Code-Generation-Setup"><a href="#3-2-Code-Generation-Setup" class="headerlink" title="3.2. Code Generation Setup"></a>3.2. Code Generation Setup</h2><p>为了生成LLVM IR，我们需要先进行一些简单的操作。首先，我们在每个AST类里定义了一个虚函数——代码生成器<code>codegen</code>方法。</p>
<!-- In order to generate LLVM IR, we want some simple setup to get started. First we define virtual code generation (codegen) methods in each AST class: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprAST</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~ExprAST() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Value *<span class="title">codegen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NumberExprAST - Expression class for numeric literals like "1.0".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NumberExprAST(<span class="keyword">double</span> Val) : Val(Val) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Value *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>codegen()</code>方法用来生成所在的AST节点以及它依赖的所有东西的IR，所有的<code>codegen()</code>都会返回一个LLVM Value对象。”Value”是用来表示一个LLVM中的<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="noopener">静态单赋值(SSA)注册器</a>，或者叫”SSA value”。SSA value最独特的一点是变量的值只要在执行和它相关的指令是才会被计算，而且在和它相关的指令再次执行前，它的值不会被更新。换句话说，SSA value是“固定的”。更多相关知识，请阅读<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="noopener">Static Single Assignment</a>，当你理解后，你就会发现这个概念非常的自然。</p>
<!-- The codegen() method says to emit IR for that AST node along with all the things it depends on, and they all return an LLVM Value object. “Value” is the class used to represent a “[Static Single Assignment (SSA) register](http://en.wikipedia.org/wiki/Static_single_assignment_form)” or “SSA value” in LLVM. The most distinct aspect of SSA values is that their value is computed as the related instruction executes, and it does not get a new value until (and if) the instruction re-executes. In other words, there is no way to “change” an SSA value. For more information, please read up on [Static Single Assignment](http://en.wikipedia.org/wiki/Static_single_assignment_form) - the concepts are really quite natural once you grok them. -->
<p>注意，除了在ExprAST类的继承体系中添加虚函数这种方案，你还可以使用<a href="http://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="noopener">visitor pattern</a>或者其他方案去做这件事情。再强调一次，这篇教程并不是一个好的软件工程实践，我们的目标是尽量简化不必要的学习，让你专注于LLVM，所以针对这个目标，虚函数是一个简单的方案。</p>
<!-- Note that instead of adding virtual methods to the ExprAST class hierarchy, it could also make sense to use a [visitor pattern](http://en.wikipedia.org/wiki/Visitor_pattern) or some other way to model this. Again, this tutorial won’t dwell on good software engineering practices: for our purposes, adding a virtual method is simplest. -->
<p>我们要做的第二件事情是增加一个“LogError”方法，用在语法分析上，在代码生成阶段用来报错（比如说，使用未定义的参数）：</p>
<!-- The second thing we want is an “LogError” method like we used for the parser, which will be used to report errors found during code generation (for example, use of an undeclared parameter): -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> LLVMContext TheContext;</span><br><span class="line"><span class="keyword">static</span> IRBuilder&lt;&gt; Builder(TheContext);</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Module&gt; TheModule;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Value *&gt; NamedValues;</span><br><span class="line"></span><br><span class="line"><span class="function">Value *<span class="title">LogErrorV</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *Str)</span> </span>&#123;</span><br><span class="line">  LogError(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些静态变量将会在代码生成阶段使用。<code>TheContext</code>是一个不透明的对象，保存着很多LLVM核心数据结构，比如数据类型和constant值的表。我们不需要从细节上理解它，我们只需要一个实例，用来传递给需要这个实例的APIs。</p>
<!-- The static variables will be used during code generation. `TheContext` is an opaque object that owns a lot of core LLVM data structures, such as the type and constant value tables. We don’t need to understand it in detail, we just need a single instance to pass into APIs that require it. -->
<p><code>Builder</code>对象是一个很有帮助的对象，让生成LLVM指令更加方便。<a href="http://llvm.org/doxygen/IRBuilder_8h-source.html" target="_blank" rel="noopener">IRBuilder</a>类模版的实例会跟踪当前要插入指令的位置，同时有创建新指令的方法可以调用。</p>
<!-- The `Builder` object is a helper object that makes it easy to generate LLVM instructions. Instances of the [IRBuilder](http://llvm.org/doxygen/IRBuilder_8h-source.html) class template keep track of the current place to insert instructions and has methods to create new instructions. -->
<p><code>TheModule</code>是一个LLVM的construct，包含了函数和全局变量。在许多方面，它是LLVM IR用来包含代码的顶层结构体。它还包含了存储我们生成的IR的内存，所以codegen()方法返回的是原始的Value*，而不是一个unique_ptr\<value\>。</value\></p>
<!-- `TheModule` is an LLVM construct that contains functions and global variables. In many ways, it is the top-level structure that the LLVM IR uses to contain code. It will own the memory for all of the IR that we generate, which is why the codegen() method returns a raw Value\*, rather than a unique_ptr\<Value\>. -->
<p><code>NamedValues</code> map保存了当前作用域里，定义了哪些变量，以及它们的LLVM表示是什么。（换句话说，这是一个代码的符号表）。在Kaleidoscope的格式中，它们唯一可以被引用的东西是函数参数。这样一来，在为它们的函数体生成代码后，函数的参数就会保存在这个map中。</p>
<!-- The `NamedValues` map keeps track of which values are defined in the current scope and what their LLVM representation is. (In other words, it is a symbol table for the code). In this form of Kaleidoscope, the only things that can be referenced are function parameters. As such, function parameters will be in this map when generating code for their function body. -->
<p>有了这些基础，我们可以开始讨论如何为每个表达式生成代码了。注意，我们假设<code>Builder</code>已经设置好，可以生成代码。现在，我们将会假设这些都已经完成了，我们会用它来生成代码。</p>
<!-- With these basics in place, we can start talking about how to generate code for each expression. Note that this assumes that the `Builder` has been set up to generate code into something. For now, we’ll assume that this has already been done, and we’ll just use it to emit code. -->
<h2 id="3-3-Expression-Code-Generation"><a href="#3-3-Expression-Code-Generation" class="headerlink" title="3.3. Expression Code Generation"></a>3.3. Expression Code Generation</h2><p>生成表达式节点的LLVM code非常直观：对于全部的四种表达式节点，只需要不到45行的带注释的代码。首先，我们处理数值字面量：</p>
<!--Generating LLVM code for expression nodes is very straightforward: less than 45 lines of commented code for all four of our expression nodes. First we’ll do numeric literals:-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value *NumberExprAST::codegen() &#123;</span><br><span class="line">  <span class="keyword">return</span> ConstantFP::get(TheContext, APFloat(Val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在LLVM IR中，数值固定量用<code>ConstantFP</code>类来表示，类中有一个<code>APFloat</code>变量（<code>APFloat</code>可以保存任意精度的浮点数）。上面这段代码简单地创建并返回一个<code>ConstantFP</code>类的变量。注意在LLVM IR中，constants are all uniqued together and shared。因为这个原因，API使用“foo::get(…)”代替“new foo(..)”和“foo::Create(..)”。</p>
<!-- In the LLVM IR, numeric constants are represented with the `ConstantFP` class, which holds the numeric value in an `APFloat` internally (`APFloat` has the capability of holding floating point constants of Arbitrary Precision). This code basically just creates and returns a `ConstantFP`. Note that in the LLVM IR that constants are all uniqued together and shared. For this reason, the API uses the “foo::get(...)” idiom instead of “new foo(..)” or “foo::Create(..)”. -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Value *VariableExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Look this variable up in the function.</span></span><br><span class="line">  Value *V = NamedValues[Name];</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    LogErrorV(<span class="string">"Unknown variable name"</span>);</span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用LLVM处理变量的引用也非常简单。在Kaleidoscope的简单版本中，我们假设变量已经在某处定义，并且变量的值是可以获取的。实际上，<code>NamedValues</code> map中唯一能存放的变量是函数参数。上面的代码简单地检查了变量名是否在map中（如果不在，就会报出未知变量引用的错误），并返回变量的值。在后面的章节中，我们会在符号表中增加对<a href="https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl5.html#for-loop-expression" target="_blank" rel="noopener">loop induction variables</a>的支持，以及<a href="https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl7.html#user-defined-local-variables" target="_blank" rel="noopener">local variables</a>的支持。</p>
<!--References to variables are also quite simple using LLVM. In the simple version of Kaleidoscope, we assume that the variable has already been emitted somewhere and its value is available. In practice, the only values that can be in the `NamedValues` map are function arguments. This code simply checks to see that the specified name is in the map (if not, an unknown variable is being referenced) and returns the value for it. In future chapters, we’ll add support for [loop induction variables](https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl5.html#for-loop-expression) in the symbol table, and for [local variables](https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl7.html#user-defined-local-variables).-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Value *BinaryExprAST::codegen() &#123;</span><br><span class="line">  Value *L = LHS-&gt;codegen();</span><br><span class="line">  Value *R = RHS-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFAdd(L, R, <span class="string">"addtmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFSub(L, R, <span class="string">"subtmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFMul(L, R, <span class="string">"multmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    L = Builder.CreateFCmpULT(L, R, <span class="string">"cmptmp"</span>);</span><br><span class="line">    <span class="comment">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class="line">    <span class="keyword">return</span> Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext),</span><br><span class="line">                                <span class="string">"booltmp"</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"invalid binary operator"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从二元运算符开始，事情就比较有趣了。基本的思路是循环地生成代码，顺序是先处理左值，后处理右值，最后计算二元表达式的结果。在上面的代码中，我们做了一个简单的switch，跳转到正确的生成LLVM指令的代码处。</p>
<!-- Binary operators start to get more interesting. The basic idea here is that we recursively emit code for the left-hand side of the expression, then the right-hand side, then we compute the result of the binary expression. In this code, we do a simple switch on the opcode to create the right LLVM instruction. -->
<p>在上面的例子中，LLVM builder类开始展现它的能力了。IRBuilder知道当前应该在哪里查处新创建的指令，你需要做的只是判定该生成什么指令（比如说<code>CreateFAdd</code>），操作数是哪些（在上面的代码中是<code>L</code>和<code>R</code>），你也可以选择性地为生成的指令命名。</p>
<!-- In the example above, the LLVM builder class is starting to show its value. IRBuilder knows where to insert the newly created instruction, all you have to do is specify what instruction to create (e.g. with `CreateFAdd`), which operands to use (`L` and `R` here) and optionally provide a name for the generated instruction. -->
<p>LLVM有一个很好的特点是，名字只是一个指示。比如说，如果上面的代码生成了多个“addtmp”变量，LLVM可以自动地设置每次加一的后缀数字，保证命名的唯一性。指令的局部value命名真的是可选的，但是它可以让阅读IR dumps更容易。</p>
<!-- One nice thing about LLVM is that the name is just a hint. For instance, if the code above emits multiple “addtmp” variables, LLVM will automatically provide each one with an increasing, unique numeric suffix. Local value names for instructions are purely optional, but it makes it much easier to read the IR dumps. -->
<p><a href="https://releases.llvm.org/5.0.0/docs/LangRef.html#instruction-reference" target="_blank" rel="noopener">LLVM instructions</a>的格式很严格：比如说，<a href="https://releases.llvm.org/5.0.0/docs/LangRef.html#add-instruction" target="_blank" rel="noopener">add instruction</a>两侧的操作数类型必须一样，加法的结果的类型过必须和操作类型匹配。因为Kaleidoscope中所有的值都是double型，使得加法、减法和乘法的代码非常简单。</p>
<!-- [LLVM instructions](https://releases.llvm.org/5.0.0/docs/LangRef.html#instruction-reference) are constrained by strict rules: for example, the Left and Right operators of an [add instruction](https://releases.llvm.org/5.0.0/docs/LangRef.html#add-instruction) must have the same type, and the result type of the add must match the operand types. Because all values in Kaleidoscope are doubles, this makes for very simple code for add, sub and mul. -->
<p>另一方面，LLVM可以识别<a href="https://releases.llvm.org/5.0.0/docs/LangRef.html#fcmp-instruction" target="_blank" rel="noopener">fcmp instruction</a>，并返回一个‘i1’类型的值（一种只有1个bit的整数）。问题是Kaleidoscope只有double型，它想要这个值是0.0或者1.0。为此，我们将fcmp instruction和<a href="https://releases.llvm.org/5.0.0/docs/LangRef.html#uitofp-to-instruction" target="_blank" rel="noopener">uitofp instruction</a>结合起来。这个指令将输入的整数视为无符号值，并转换成为浮点数。对比之下，如果我们用<a href="https://releases.llvm.org/5.0.0/docs/LangRef.html#sitofp-to-instruction" target="_blank" rel="noopener">sitofp instruction</a>，Kaleidoscope的‘&lt;’运算符将会根据输入返回0.0或者-1.0。</p>
<!-- On the other hand, LLVM specifies that the [fcmp instruction](https://releases.llvm.org/5.0.0/docs/LangRef.html#fcmp-instruction) always returns an ‘i1’ value (a one bit integer). The problem with this is that Kaleidoscope wants the value to be a 0.0 or 1.0 value. In order to get these semantics, we combine the fcmp instruction with a [uitofp instruction](https://releases.llvm.org/5.0.0/docs/LangRef.html#uitofp-to-instruction). This instruction converts its input integer into a floating point value by treating the input as an unsigned value. In contrast, if we used the [sitofp instruction](https://releases.llvm.org/5.0.0/docs/LangRef.html#sitofp-to-instruction), the Kaleidoscope ‘<’ operator would return 0.0 and -1.0, depending on the input value. -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Value *CallExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Look up the name in the global module table.</span></span><br><span class="line">  Function *CalleeF = TheModule-&gt;getFunction(Callee);</span><br><span class="line">  <span class="keyword">if</span> (!CalleeF)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown function referenced"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If argument mismatch error.</span></span><br><span class="line">  <span class="keyword">if</span> (CalleeF-&gt;arg_size() != Args.size())</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Incorrect # arguments passed"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Value *&gt; ArgsV;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, e = Args.size(); i != e; ++i) &#123;</span><br><span class="line">    ArgsV.push_back(Args[i]-&gt;codegen());</span><br><span class="line">    <span class="keyword">if</span> (!ArgsV.back())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Builder.CreateCall(CalleeF, ArgsV, <span class="string">"calltmp"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LLVM中，函数调用的代码生成也非常直观。上面的代码首先在LLVM Modules的符号表中查找函数名。之前提到过，LLVM Module是在即使编译的过程中，保存函数的容器。By giving each function the same name as what the user specifies, we can use the LLVM symbol table to resolve function names for us.</p>
<!-- Code generation for function calls is quite straightforward with LLVM. The code above initially does a function name lookup in the LLVM Module’s symbol table. Recall that the LLVM Module is the container that holds the functions we are JIT’ing. By giving each function the same name as what the user specifies, we can use the LLVM symbol table to resolve function names for us. -->
<p>有了可以处理函数调用的方法以后，我们就可以循环地生成需要传递的每个参数，并且创建一个LLVM <a href="https://releases.llvm.org/5.0.0/docs/LangRef.html#call-instruction" target="_blank" rel="noopener">call instruction</a>。注意，默认情况下，LLVM使用本地C语言的函数调用规范，允许这些函数调用同时调用标准库的函数，比如“sin”、“cos”，而且不需要额外的工作。</p>
<!-- Once we have the function to call, we recursively codegen each argument that is to be passed in, and create an LLVM [call instruction](https://releases.llvm.org/5.0.0/docs/LangRef.html#call-instruction). Note that LLVM uses the native C calling conventions by default, allowing these calls to also call into standard library functions like “sin” and “cos”, with no additional effort. -->
<p>上面的代码封装了我们至今为止在Kaleidoscope定义的四种基本表达式。你可以增加更多类型的表达式。比如说，你可以浏览<a href="https://releases.llvm.org/5.0.0/docs/LangRef.html" target="_blank" rel="noopener">LLVM language reference</a>，你会发现有很多有趣的指令，它们可以非常简单地添加到我们的基础框架中。</p>
<!-- This wraps up our handling of the four basic expressions that we have so far in Kaleidoscope. Feel free to go in and add some more. For example, by browsing the [LLVM language reference](https://releases.llvm.org/5.0.0/docs/LangRef.html) you’ll find several other interesting instructions that are really easy to plug into our basic framework. -->
<h2 id="3-4-Function-Code-Generation"><a href="#3-4-Function-Code-Generation" class="headerlink" title="3.4. Function Code Generation"></a>3.4. Function Code Generation</h2><p>函数原型和函数体的代码生成必须处理很多细节问题，这会让处理函数的代码不如处理表达式的代码优雅，但是可以让我们说明很多重要的点。首先，我们讨论函数原型代码生成：它们用在函数体和外部函数声明上。代码的开头部分如下：</p>
<!-- Code generation for prototypes and functions must handle a number of details, which make their code less beautiful than expression code generation, but allows us to illustrate some important points. First, lets talk about code generation for prototypes: they are used both for function bodies and external function declarations. The code starts with: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function *PrototypeAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Make the function type:  double(double,double) etc.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type*&gt; Doubles(Args.size(),</span><br><span class="line">                             Type::getDoubleTy(TheContext));</span><br><span class="line">  FunctionType *FT =</span><br><span class="line">    FunctionType::get(Type::getDoubleTy(TheContext), Doubles, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  Function *F =</span><br><span class="line">    Function::Create(FT, Function::ExternalLinkage, Name, TheModule);</span><br></pre></td></tr></table></figure>
<p>上面的代码虽然只有几行，但实际上处理了很多事情。首先，注意上面这个函数的返回值类型是“Function*”，而不是“Value*”。因为一个“函数原型”讨论的是一个函数的外部接口（而不是一个表达式计算出来的值），所以在生成代码时，返回它对应的LLVM Function是有意义的。</p>
<!-- This code packs a lot of power into a few lines. Note first that this function returns a “Function\*” instead of a “Value\*”. Because a “prototype” really talks about the external interface for a function (not the value computed by an expression), it makes sense for it to return the LLVM Function it corresponds to when codegen’d. -->
<p>对<code>FunctionType::get</code>的调用创建了应该在给定的函数原型中用到的<code>FunctionType</code>。因为Kaleidoscope中所有的函数参数都是double型的，上面函数体内第一行代码创建了一个长度为“N”的LLVM double型的vector。然后使用<code>Functiontype::get</code>方法创建了一个function type，它接受“N”个double型变量为参数，并返回一个double型变量，</p>
<p>The call to <code>FunctionType::get</code> creates the <code>FunctionType</code> that should be used for a given Prototype. Since all function arguments in Kaleidoscope are of type double, the first line creates a vector of “N” LLVM double types. It then uses the <code>Functiontype::get</code> method to create a function type that takes “N” doubles as arguments, returns one double as a result, and that is not vararg (the false parameter indicates this). Note that Types in LLVM are uniqued just like Constants are, so you don’t “new” a type, you “get” it.</p>
<p>上面的最后一行代码创建了函数原型对应的实际的IR Function。这表示type、linkage、使用的名字、以及在哪个module中插入代码。“<a href="https://releases.llvm.org/5.0.0/docs/LangRef.html#linkage" target="_blank" rel="noopener">external linkage</a>”意味着这个函数可能在当前module外定义，或者在当前module外可以被调用。</p>
<p>The final line above actually creates the IR Function corresponding to the Prototype. This indicates the type, linkage and name to use, as well as which module to insert into. “<a href="https://releases.llvm.org/5.0.0/docs/LangRef.html#linkage" target="_blank" rel="noopener">external linkage</a>” means that the function may be defined outside the current module and/or that it is callable by functions outside the module. The Name passed in is the name the user specified: since “<code>TheModule</code>” is specified, this name is registered in “<code>TheModule</code>“s symbol table.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set names for all arguments.</span></span><br><span class="line"><span class="keyword">unsigned</span> Idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : F-&gt;args())</span><br><span class="line">  Arg.setName(Args[Idx++]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> F;</span><br></pre></td></tr></table></figure>
<p>最后，我们按照函数原型中的名字为每个函数参数命名。这一步严格来说不是必须的，但是保持命名一致可以提高IR的可读性，并且让后面的代码可以直接通过参数的名字来引用它们，而不用在函数原型的AST中搜索它们。</p>
<!-- Finally, we set the name of each of the function’s arguments according to the names given in the Prototype. This step isn’t strictly necessary, but keeping the names consistent makes the IR more readable, and allows subsequent code to refer directly to the arguments for their names, rather than having to look up them up in the Prototype AST. -->
<p>现在我们有了不包含函数体的函数原型。这就是LLVM IR表示函数定义的方法。对Kaleidoscope中的extern语句来说，这就是我们需要做的全部了。然而对于函数定义来说，我们需要codegen，并且连接上一个函数体。</p>
<!-- At this point we have a function prototype with no body. This is how LLVM IR represents function declarations. For extern statements in Kaleidoscope, this is as far as we need to go. For function definitions however, we need to codegen and attach a function body. -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Function *FunctionAST::codegen() &#123;</span><br><span class="line">    <span class="comment">// First, check for an existing function from a previous 'extern' declaration.</span></span><br><span class="line">  Function *TheFunction = TheModule-&gt;getFunction(Proto-&gt;getName());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    TheFunction = Proto-&gt;codegen();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!TheFunction-&gt;empty())</span><br><span class="line">    <span class="keyword">return</span> (Function*)LogErrorV(<span class="string">"Function cannot be redefined."</span>);</span><br></pre></td></tr></table></figure>
<p>对函数定义来说，我们首先在TheModule的symbol table中查找这个函数，以防这个函数已经用‘extern’语句创建过了。如果Module::getFunction返回一个null，表明这个函数没有previous version，那么我们就可以从函数原型中codegen处一个。在各种情况下，如果函数是empty（也就是说，至今为止没有函数体），我们会在开始前assert。</p>
<!-- For function definitions, we start by searching TheModule’s symbol table for an existing version of this function, in case one has already been created using an ‘extern’ statement. If Module::getFunction returns null then no previous version exists, so we’ll codegen one from the Prototype. In either case, we want to assert that the function is empty (i.e. has no body yet) before we start. -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new basic block to start insertion into.</span></span><br><span class="line">BasicBlock *BB = BasicBlock::Create(TheContext, <span class="string">"entry"</span>, TheFunction);</span><br><span class="line">Builder.SetInsertPoint(BB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">NamedValues.clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;args())</span><br><span class="line">  NamedValues[Arg.getName()] = &amp;Arg;</span><br></pre></td></tr></table></figure>
<p>现在<code>Builder</code>已经设置好了。上面代码的第一行创建了一个新的<a href="http://en.wikipedia.org/wiki/Basic_block" target="_blank" rel="noopener">basic block</a>（名为“entry”），插入在<code>TheFunction</code>中。第二行告诉builder新的指令应该插入在新的basic block后面。LLVM中的basic blocks是函数中很重要的组成部分，定义了<a href="http://en.wikipedia.org/wiki/Control_flow_graph" target="_blank" rel="noopener">Control Flow Graph</a>。因为我们没有任何控制流，我们的函数当前只有一个block。我们将会在<a href="https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl05.html" target="_blank" rel="noopener">Chapter 5</a>进行增补。</p>
<!-- Now we get to the point where the `Builder` is set up. The first line creates a new [basic block](http://en.wikipedia.org/wiki/Basic_block) (named “entry”), which is inserted into `TheFunction`. The second line then tells the builder that new instructions should be inserted into the end of the new basic block. Basic blocks in LLVM are an important part of functions that define the [Control Flow Graph](http://en.wikipedia.org/wiki/Control_flow_graph). Since we don’t have any control flow, our functions will only contain one block at this point. We’ll fix this in [Chapter 5](https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl05.html) :). -->
<p>然后，我们在NamedValues map（在首次将它清空之后）中添加了函数参数，让它们可以连接到<code>VariableExprAST</code>节点。</p>
<!-- Next we add the function arguments to the NamedValues map (after first clearing it out) so that they’re accessible to `VariableExprAST` nodes. -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Value *RetVal = Body-&gt;codegen()) &#123;</span><br><span class="line">  <span class="comment">// Finish off the function.</span></span><br><span class="line">  Builder.CreateRet(RetVal);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate the generated code, checking for consistency.</span></span><br><span class="line">  verifyFunction(*TheFunction);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TheFunction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置好插入点，填充完NamedValues map后，我们为函数体的第一个表达式调用<code>codegen()</code>方法。如果没有错误，它会生成计算这个表达式的代码，插入到entry block，并且返回它计算得到的表达式的值。假设没有错误发生，我们接下来创建一条LLVM <a href="https://releases.llvm.org/5.0.0/docs/LangRef.html#ret-instruction" target="_blank" rel="noopener">ret instruction</a>，它会完成函数的构造。函数构造完成后，我们调用LLVM提供的<code>verifyFunction</code>，它会对生成的代码进行一系列的一致性检查，来验证我们的编译器每件事都做得正确。使用<code>verifyFunction</code>是很重要的：它能捕获很多bugs。当函数构造完成并且验证完成后，我们将它返回。</p>
<!-- Once the insertion point has been set up and the NamedValues map populated, we call the `codegen()` method for the root expression of the function. If no error happens, this emits code to compute the expression into the entry block and returns the value that was computed. Assuming no error, we then create an LLVM [ret instruction](https://releases.llvm.org/5.0.0/docs/LangRef.html#ret-instruction), which completes the function. Once the function is built, we call `verifyFunction`, which is provided by LLVM. This function does a variety of consistency checks on the generated code, to determine if our compiler is doing everything right. Using this is important: it can catch a lot of bugs. Once the function is finished and validated, we return it. -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Error reading body, remove function.</span></span><br><span class="line">  TheFunction-&gt;eraseFromParent();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在剩下的部分就是处理错误了。简单起见，当出错时，我们简单地调用<code>eraseFromParent</code>方法将函数删除。这让用户可以重新定义他们之前输入错误的函数：如果我们没有删除那个函数，那个函数仍然会在symbol table中，它有函数体，所以会阻止重定义。</p>
<!-- The only piece left here is handling of the error case. For simplicity, we handle this by merely deleting the function we produced with the `eraseFromParent` method. This allows the user to redefine a function that they incorrectly typed in before: if we didn’t delete it, it would live in the symbol table, with a body, preventing future redefinition. -->
<p>上面的代码有一个bug：如果<code>FunctionAST::codegen()</code>方法找到一个已经存在的IR Function，它并不验证函数签名和函数定义的prototype是否相同。这意味着更早的‘extern’定义比函数定义的signature有更高的优先级，这可能导致codegen失败，（比如当函数参数命名不一致时）。有几种方法去修复这个bug，这需要你自己动脑去想。下面是一个测试用例：</p>
<!-- This code does have a bug, though: If the `FunctionAST::codegen()` method finds an existing IR Function, it does not validate its signature against the definition’s own prototype. This means that an earlier ‘extern’ declaration will take precedence over the function definition’s signature, which can cause codegen to fail, for instance if the function arguments are named differently. There are a number of ways to fix this bug, see what you can come up with! Here is a testcase: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">foo</span><span class="params">(a)</span></span>;     <span class="meta"># ok, defines foo.</span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(b)</span> b</span>;      # Error: Unknown variable name. (decl <span class="keyword">using</span> <span class="string">'a'</span> takes precedence).</span><br></pre></td></tr></table></figure>
<h2 id="3-5-Driver-Changes-and-Closing-Thoughts"><a href="#3-5-Driver-Changes-and-Closing-Thoughts" class="headerlink" title="3.5. Driver Changes and Closing Thoughts"></a>3.5. Driver Changes and Closing Thoughts</h2><p>至今为止，code generation to LLVM doesn’t really get us much，除了能看到优雅的IR调用。调用codegen将样例代码插入“<code>HandleDefinition</code>”、“<code>HandleExtern</code>”等函数，然后dumps out LLVM IR。这提供了一个查看简单函数的LLVM IR的很好的途径。举例来说：</p>
<!-- For now, code generation to LLVM doesn’t really get us much, except that we can look at the pretty IR calls. The sample code inserts calls to codegen into the “`HandleDefinition`”, “`HandleExtern`” etc functions, and then dumps out the LLVM IR. This gives a nice way to look at the LLVM IR for simple functions. For example: -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; 4+5;</span><br><span class="line">Read top-level expression:</span><br><span class="line">define double @<span class="function">0</span>() &#123;</span><br><span class="line">entry:</span><br><span class="line">  ret double 9.000000e+00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意语法分析器是如何将顶层表达式为我们转换成匿名函数的。这一特性在下一章我们增加<a href="https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl4.html#adding-a-jit-compiler" target="_blank" rel="noopener">JIT support</a>时非常好用。同时，注意代码基本是直接翻译过来的，没有怎么优化，除了IRBuilder做的简单的constant folding。我们将会在下一章明确地<a href="https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl4.html#trivial-constant-folding" target="_blank" rel="noopener">add optimizations</a>。</p>
<!-- Note how the parser turns the top-level expression into anonymous functions for us. This will be handy when we add [JIT support](https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl4.html#adding-a-jit-compiler) in the next chapter. Also note that the code is very literally transcribed, no optimizations are being performed except simple constant folding done by IRBuilder. We will [add optimizations](https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl4.html#trivial-constant-folding) explicitly in the next chapter. -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def foo(a b) a*a + 2*a*b + b*b;</span><br><span class="line">Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @foo(double %a, double %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %multmp = fmul double %a, %a</span><br><span class="line">  %multmp1 = fmul double 2.000000e+00, %a</span><br><span class="line">  %multmp2 = fmul double %multmp1, %b</span><br><span class="line">  %addtmp = fadd double %multmp, %multmp2</span><br><span class="line">  %multmp3 = fmul double %b, %b</span><br><span class="line">  %addtmp4 = fadd double %addtmp, %multmp3</span><br><span class="line">  ret double %addtmp4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码展示了简单的算术运算。注意，我们使用的LLVM builder calls的指令非常相似。</p>
<!-- This shows some simple arithmetic. Notice the striking similarity to the LLVM builder calls that we use to create the instructions. -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def bar(a) foo(a, 4.0) + bar(31337);</span><br><span class="line">Read function definition:</span><br><span class="line">define double @bar(double %a) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call double @foo(double %a, double 4.000000e+00)</span><br><span class="line">  %calltmp1 = call double @bar(double 3.133700e+04)</span><br><span class="line">  %addtmp = fadd double %calltmp, %calltmp1</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码展示了函数调用。注意如果你调用这个函数的话，它会执行很长的时间。将来我们会增加条件控制流，让递归变得实际可用。</p>
<!-- This shows some function calls. Note that this function will take a long time to execute if you call it. In the future we’ll add conditional control flow to actually make recursion useful :). -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; extern cos(x);</span><br><span class="line">Read extern:</span><br><span class="line">declare double @cos(double)</span><br><span class="line"></span><br><span class="line">ready&gt; cos(1.234);</span><br><span class="line">Read top-level expression:</span><br><span class="line">define double @1() &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call double @cos(double 1.234000e+00)</span><br><span class="line">  ret double %calltmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码展示了数学库中“cos”函数的extern，以及对它的一次调用。</p>
<!-- This shows an extern for the libm “cos” function, and a call to it. -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; ^D</span><br><span class="line">; ModuleID = &apos;my cool jit&apos;</span><br><span class="line"></span><br><span class="line">define double @0() &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd double 4.000000e+00, 5.000000e+00</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define double @foo(double %a, double %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %multmp = fmul double %a, %a</span><br><span class="line">  %multmp1 = fmul double 2.000000e+00, %a</span><br><span class="line">  %multmp2 = fmul double %multmp1, %b</span><br><span class="line">  %addtmp = fadd double %multmp, %multmp2</span><br><span class="line">  %multmp3 = fmul double %b, %b</span><br><span class="line">  %addtmp4 = fadd double %addtmp, %multmp3</span><br><span class="line">  ret double %addtmp4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define double @bar(double %a) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call double @foo(double %a, double 4.000000e+00)</span><br><span class="line">  %calltmp1 = call double @bar(double 3.133700e+04)</span><br><span class="line">  %addtmp = fadd double %calltmp, %calltmp1</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare double @cos(double)</span><br><span class="line"></span><br><span class="line">define double @1() &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call double @cos(double 1.234000e+00)</span><br><span class="line">  ret double %calltmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你退出当前demo（通过Linux下CTRL+D，或者Windows下CTRL+Z and ENTER，发送一个EOF信号），会dumps out生成的整个module的IR。这样你就可以看到所有的函数引用。</p>
<!-- When you quit the current demo (by sending an EOF via CTRL+D on Linux or CTRL+Z and ENTER on Windows), it dumps out the IR for the entire module generated. Here you can see the big picture with all the functions referencing each other. -->
<p>现在封装了Kaleidoscope教程第三章的内容。下一章，我们将介绍如何<a href="https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl04.html" target="_blank" rel="noopener">add JIT codegen and optimizer support</a>，来让我们可以实际运行代码。</p>
<!-- This wraps up the third chapter of the Kaleidoscope tutorial. Up next, we’ll describe how to [add JIT codegen and optimizer support](https://releases.llvm.org/5.0.0/docs/tutorial/LangImpl04.html) to this so we can actually start running code! -->
<h2 id="3-6-Full-Code-Listing"><a href="#3-6-Full-Code-Listing" class="headerlink" title="3.6. Full Code Listing"></a>3.6. Full Code Listing</h2><p>这里是我们样例的完整代码，用LLVM code generator强化过的代码。因为使用到了LLVM库，我们需要把它们链接进来。为了做到这一点，我们使用<a href="http://llvm.org/cmds/llvm-config.html" target="_blank" rel="noopener">llvm-config</a>工具去告知makefile/command line我们要用哪些参数选项。</p>
<!-- Here is the complete code listing for our running example, enhanced with the LLVM code generator. Because this uses the LLVM libraries, we need to link them in. To do this, we use the [llvm-config](http://llvm.org/cmds/llvm-config.html) tool to inform our makefile/command line about which options to use: -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compile</span></span><br><span class="line">clang++ -g -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy</span><br><span class="line"><span class="comment"># Run</span></span><br><span class="line">./toy</span><br></pre></td></tr></table></figure>
<p>下面是完整代码：</p>
<!-- Here is the code: -->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/ADT/APFloat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/ADT/STLExtras.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/BasicBlock.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/DerivedTypes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Function.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/IRBuilder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/LLVMContext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Module.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Type.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Verifier.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Lexer</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The lexer returns tokens [0-255] if it is an unknown character, otherwise one</span></span><br><span class="line"><span class="comment">// of these for known things.</span></span><br><span class="line"><span class="keyword">enum</span> Token &#123;</span><br><span class="line">  tok_eof = <span class="number">-1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// commands</span></span><br><span class="line">  tok_def = <span class="number">-2</span>,</span><br><span class="line">  tok_extern = <span class="number">-3</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// primary</span></span><br><span class="line">  tok_identifier = <span class="number">-4</span>,</span><br><span class="line">  tok_number = <span class="number">-5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> IdentifierStr; <span class="comment">// Filled in if tok_identifier</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> NumVal;             <span class="comment">// Filled in if tok_number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// gettok - Return the next token from standard input.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gettok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> LastChar = <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip any whitespace.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isspace</span>(LastChar))</span><br><span class="line">    LastChar = getchar();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isalpha</span>(LastChar)) &#123; <span class="comment">// identifier: [a-zA-Z][a-zA-Z0-9]*</span></span><br><span class="line">    IdentifierStr = LastChar;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalnum</span>((LastChar = getchar())))</span><br><span class="line">      IdentifierStr += LastChar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"def"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_def;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"extern"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_extern;</span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">'.'</span>) &#123; <span class="comment">// Number: [0-9.]+</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> NumStr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      NumStr += LastChar;</span><br><span class="line">      LastChar = getchar();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    NumVal = strtod(NumStr.c_str(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> tok_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (LastChar == <span class="string">'#'</span>) &#123;</span><br><span class="line">    <span class="comment">// Comment until end of line.</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      LastChar = getchar();</span><br><span class="line">    <span class="keyword">while</span> (LastChar != EOF &amp;&amp; LastChar != <span class="string">'\n'</span> &amp;&amp; LastChar != <span class="string">'\r'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LastChar != EOF)</span><br><span class="line">      <span class="keyword">return</span> gettok();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for end of file.  Don't eat the EOF.</span></span><br><span class="line">  <span class="keyword">if</span> (LastChar == EOF)</span><br><span class="line">    <span class="keyword">return</span> tok_eof;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, just return the character as its ascii value.</span></span><br><span class="line">  <span class="keyword">int</span> ThisChar = LastChar;</span><br><span class="line">  LastChar = getchar();</span><br><span class="line">  <span class="keyword">return</span> ThisChar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Abstract Syntax Tree (aka Parse Tree)</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprAST</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~ExprAST() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Value *<span class="title">codegen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NumberExprAST - Expression class for numeric literals like "1.0".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NumberExprAST(<span class="keyword">double</span> Val) : Val(Val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// VariableExprAST - Expression class for referencing a variable, like "a".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  VariableExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Name) : Name(Name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinaryExprAST - Expression class for a binary operator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">char</span> Op;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS, RHS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  BinaryExprAST(<span class="keyword">char</span> Op, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS,</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; RHS)</span><br><span class="line">      : Op(Op), LHS(<span class="built_in">std</span>::move(LHS)), RHS(<span class="built_in">std</span>::move(RHS)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CallExprAST - Expression class for function calls.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Callee;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  CallExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Callee,</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args)</span><br><span class="line">      : Callee(Callee), Args(<span class="built_in">std</span>::move(Args)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// PrototypeAST - This class represents the "prototype" for a function,</span></span><br><span class="line"><span class="comment">/// which captures its name, and its argument names (thus implicitly the number</span></span><br><span class="line"><span class="comment">/// of arguments the function takes).</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PrototypeAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Name, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args)</span><br><span class="line">      : Name(Name), Args(<span class="built_in">std</span>::move(Args)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Function *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// FunctionAST - This class represents a function definition itself.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  FunctionAST(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto,</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body)</span><br><span class="line">      : Proto(<span class="built_in">std</span>::move(Proto)), Body(<span class="built_in">std</span>::move(Body)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Function *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Parser</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current</span></span><br><span class="line"><span class="comment">/// token the parser is looking at.  getNextToken reads another token from the</span></span><br><span class="line"><span class="comment">/// lexer and updates CurTok with its results.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> CurTok;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextToken</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CurTok = gettok(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinopPrecedence - This holds the precedence for each binary operator that is</span></span><br><span class="line"><span class="comment">/// defined.</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; BinopPrecedence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// GetTokPrecedence - Get the precedence of the pending binary operator token.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetTokPrecedence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isascii(CurTok))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure it's a declared binop.</span></span><br><span class="line">  <span class="keyword">int</span> TokPrec = BinopPrecedence[CurTok];</span><br><span class="line">  <span class="keyword">if</span> (TokPrec &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> TokPrec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// LogError* - These are little helper functions for error handling.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LogError(<span class="keyword">const</span> <span class="keyword">char</span> *Str) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: %s\n"</span>, Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; LogErrorP(<span class="keyword">const</span> <span class="keyword">char</span> *Str) &#123;</span><br><span class="line">  LogError(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseExpression();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// numberexpr ::= number</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseNumberExpr() &#123;</span><br><span class="line">  <span class="keyword">auto</span> Result = llvm::make_unique&lt;NumberExprAST&gt;(NumVal);</span><br><span class="line">  getNextToken(); <span class="comment">// consume the number</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(Result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// parenexpr ::= '(' expression ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseParenExpr() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat (.</span></span><br><span class="line">  <span class="keyword">auto</span> V = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected ')'"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat ).</span></span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= identifier</span></span><br><span class="line"><span class="comment">///   ::= identifier '(' expression* ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseIdentifierExpr() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> IdName = IdentifierStr;</span><br><span class="line"></span><br><span class="line">  getNextToken(); <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>) <span class="comment">// Simple variable ref.</span></span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;VariableExprAST&gt;(IdName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call.</span></span><br><span class="line">  getNextToken(); <span class="comment">// eat (</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Arg = ParseExpression())</span><br><span class="line">        Args.push_back(<span class="built_in">std</span>::move(Arg));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok == <span class="string">')'</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok != <span class="string">','</span>)</span><br><span class="line">        <span class="keyword">return</span> LogError(<span class="string">"Expected ')' or ',' in argument list"</span>);</span><br><span class="line">      getNextToken();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eat the ')'.</span></span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;CallExprAST&gt;(IdName, <span class="built_in">std</span>::move(Args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// primary</span></span><br><span class="line"><span class="comment">///   ::= identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= numberexpr</span></span><br><span class="line"><span class="comment">///   ::= parenexpr</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParsePrimary() &#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"unknown token when expecting an expression"</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> ParseIdentifierExpr();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> ParseNumberExpr();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">    <span class="keyword">return</span> ParseParenExpr();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// binoprhs</span></span><br><span class="line"><span class="comment">///   ::= ('+' primary)*</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseBinOpRHS(<span class="keyword">int</span> ExprPrec,</span><br><span class="line">                                              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS) &#123;</span><br><span class="line">  <span class="comment">// If this is a binop, find its precedence.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> TokPrec = GetTokPrecedence();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a binop that binds at least as tightly as the current binop,</span></span><br><span class="line">    <span class="comment">// consume it, otherwise we are done.</span></span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; ExprPrec)</span><br><span class="line">      <span class="keyword">return</span> LHS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Okay, we know this is a binop.</span></span><br><span class="line">    <span class="keyword">int</span> BinOp = CurTok;</span><br><span class="line">    getNextToken(); <span class="comment">// eat binop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the primary expression after the binary operator.</span></span><br><span class="line">    <span class="keyword">auto</span> RHS = ParsePrimary();</span><br><span class="line">    <span class="keyword">if</span> (!RHS)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If BinOp binds less tightly with RHS than the operator after RHS, let</span></span><br><span class="line">    <span class="comment">// the pending operator take RHS as its LHS.</span></span><br><span class="line">    <span class="keyword">int</span> NextPrec = GetTokPrecedence();</span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; NextPrec) &#123;</span><br><span class="line">      RHS = ParseBinOpRHS(TokPrec + <span class="number">1</span>, <span class="built_in">std</span>::move(RHS));</span><br><span class="line">      <span class="keyword">if</span> (!RHS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge LHS/RHS.</span></span><br><span class="line">    LHS =</span><br><span class="line">        llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, <span class="built_in">std</span>::move(LHS), <span class="built_in">std</span>::move(RHS));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// expression</span></span><br><span class="line"><span class="comment">///   ::= primary binoprhs</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseExpression() &#123;</span><br><span class="line">  <span class="keyword">auto</span> LHS = ParsePrimary();</span><br><span class="line">  <span class="keyword">if</span> (!LHS)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ParseBinOpRHS(<span class="number">0</span>, <span class="built_in">std</span>::move(LHS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///   ::= id '(' id* ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParsePrototype() &#123;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected function name in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> FnName = IdentifierStr;</span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected '(' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ArgNames;</span><br><span class="line">  <span class="keyword">while</span> (getNextToken() == tok_identifier)</span><br><span class="line">    ArgNames.push_back(IdentifierStr);</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected ')' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// success.</span></span><br><span class="line">  getNextToken(); <span class="comment">// eat ')'.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;PrototypeAST&gt;(FnName, <span class="built_in">std</span>::move(ArgNames));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// definition ::= 'def' prototype expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; ParseDefinition() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat def.</span></span><br><span class="line">  <span class="keyword">auto</span> Proto = ParsePrototype();</span><br><span class="line">  <span class="keyword">if</span> (!Proto)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = ParseExpression())</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto), <span class="built_in">std</span>::move(E));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// toplevelexpr ::= expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; ParseTopLevelExpr() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = ParseExpression()) &#123;</span><br><span class="line">    <span class="comment">// Make an anonymous proto.</span></span><br><span class="line">    <span class="keyword">auto</span> Proto = llvm::make_unique&lt;PrototypeAST&gt;(<span class="string">"__anon_expr"</span>,</span><br><span class="line">                                                 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto), <span class="built_in">std</span>::move(E));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// external ::= 'extern' prototype</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParseExtern() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat extern.</span></span><br><span class="line">  <span class="keyword">return</span> ParsePrototype();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Code Generation</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> LLVMContext TheContext;</span><br><span class="line"><span class="keyword">static</span> IRBuilder&lt;&gt; Builder(TheContext);</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Module&gt; TheModule;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Value *&gt; NamedValues;</span><br><span class="line"></span><br><span class="line"><span class="function">Value *<span class="title">LogErrorV</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *Str)</span> </span>&#123;</span><br><span class="line">  LogError(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *NumberExprAST::codegen() &#123;</span><br><span class="line">  <span class="keyword">return</span> ConstantFP::get(TheContext, APFloat(Val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *VariableExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Look this variable up in the function.</span></span><br><span class="line">  Value *V = NamedValues[Name];</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown variable name"</span>);</span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *BinaryExprAST::codegen() &#123;</span><br><span class="line">  Value *L = LHS-&gt;codegen();</span><br><span class="line">  Value *R = RHS-&gt;codegen();</span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFAdd(L, R, <span class="string">"addtmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFSub(L, R, <span class="string">"subtmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFMul(L, R, <span class="string">"multmp"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    L = Builder.CreateFCmpULT(L, R, <span class="string">"cmptmp"</span>);</span><br><span class="line">    <span class="comment">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class="line">    <span class="keyword">return</span> Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), <span class="string">"booltmp"</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"invalid binary operator"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *CallExprAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Look up the name in the global module table.</span></span><br><span class="line">  Function *CalleeF = TheModule-&gt;getFunction(Callee);</span><br><span class="line">  <span class="keyword">if</span> (!CalleeF)</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Unknown function referenced"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If argument mismatch error.</span></span><br><span class="line">  <span class="keyword">if</span> (CalleeF-&gt;arg_size() != Args.size())</span><br><span class="line">    <span class="keyword">return</span> LogErrorV(<span class="string">"Incorrect # arguments passed"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Value *&gt; ArgsV;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, e = Args.size(); i != e; ++i) &#123;</span><br><span class="line">    ArgsV.push_back(Args[i]-&gt;codegen());</span><br><span class="line">    <span class="keyword">if</span> (!ArgsV.back())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Builder.CreateCall(CalleeF, ArgsV, <span class="string">"calltmp"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function *PrototypeAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// Make the function type:  double(double,double) etc.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type *&gt; Doubles(Args.size(), Type::getDoubleTy(TheContext));</span><br><span class="line">  FunctionType *FT =</span><br><span class="line">      FunctionType::get(Type::getDoubleTy(TheContext), Doubles, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  Function *F =</span><br><span class="line">      Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set names for all arguments.</span></span><br><span class="line">  <span class="keyword">unsigned</span> Idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : F-&gt;args())</span><br><span class="line">    Arg.setName(Args[Idx++]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function *FunctionAST::codegen() &#123;</span><br><span class="line">  <span class="comment">// First, check for an existing function from a previous 'extern' declaration.</span></span><br><span class="line">  Function *TheFunction = TheModule-&gt;getFunction(Proto-&gt;getName());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    TheFunction = Proto-&gt;codegen();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new basic block to start insertion into.</span></span><br><span class="line">  BasicBlock *BB = BasicBlock::Create(TheContext, <span class="string">"entry"</span>, TheFunction);</span><br><span class="line">  Builder.SetInsertPoint(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">  NamedValues.clear();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;args())</span><br><span class="line">    NamedValues[Arg.getName()] = &amp;Arg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Value *RetVal = Body-&gt;codegen()) &#123;</span><br><span class="line">    <span class="comment">// Finish off the function.</span></span><br><span class="line">    Builder.CreateRet(RetVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate the generated code, checking for consistency.</span></span><br><span class="line">    verifyFunction(*TheFunction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TheFunction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Error reading body, remove function.</span></span><br><span class="line">  TheFunction-&gt;eraseFromParent();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Top-Level parsing and JIT Driver</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = ParseDefinition()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = FnAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read function definition:"</span>);</span><br><span class="line">      FnIR-&gt;print(errs());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> ProtoAST = ParseExtern()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = ProtoAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read extern: "</span>);</span><br><span class="line">      FnIR-&gt;print(errs());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleTopLevelExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Evaluate a top-level expression into an anonymous function.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = ParseTopLevelExpr()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = FnAST-&gt;codegen()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read top-level expression:"</span>);</span><br><span class="line">      FnIR-&gt;print(errs());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// top ::= definition | external | expression | ';'</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ready&gt; "</span>);</span><br><span class="line">    <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">    <span class="keyword">case</span> tok_eof:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">';'</span>: <span class="comment">// ignore top-level semicolons.</span></span><br><span class="line">      getNextToken();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_def:</span><br><span class="line">      HandleDefinition();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_extern:</span><br><span class="line">      HandleExtern();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      HandleTopLevelExpression();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Main driver code.</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">'&lt;'</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'+'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'-'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'*'</span>] = <span class="number">40</span>; <span class="comment">// highest.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prime the first token.</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ready&gt; "</span>);</span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the module, which holds all the code.</span></span><br><span class="line">  TheModule = llvm::make_unique&lt;Module&gt;(<span class="string">"my cool jit"</span>, TheContext);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the main "interpreter loop" now.</span></span><br><span class="line">  MainLoop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print out all of the generated code.</span></span><br><span class="line">  TheModule-&gt;print(errs(), <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/11/3-Kaleidoscope-Code-generation-to-LLVM-IR/" data-id="cjca79i4g0007la5i2iuqvhy1" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-Tutorial/">LLVM Tutorial</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/01/10/2-Kaleidoscope-Implementing-a-Parser-and-AST/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">2. Kaleidoscope: Implementing a Parser and AST</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM-Tutorial/">LLVM Tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/LLVM-Tutorial/" style="font-size: 10px;">LLVM Tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/11/3-Kaleidoscope-Code-generation-to-LLVM-IR/">3. Kaleidoscope: Code generation to LLVM IR</a>
          </li>
        
          <li>
            <a href="/2018/01/10/2-Kaleidoscope-Implementing-a-Parser-and-AST/">2. Kaleidoscope: Implementing a Parser and AST</a>
          </li>
        
          <li>
            <a href="/2018/01/10/1-Kaleidoscope-Tutorial-Introduction-and-the-Lexer/">1. Kaleidoscope: Tutorial Introduction and the Lexer</a>
          </li>
        
          <li>
            <a href="/2018/01/10/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LiTong<br>
      Propulsé par <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>