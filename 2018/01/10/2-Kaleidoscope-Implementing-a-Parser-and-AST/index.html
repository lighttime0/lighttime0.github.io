<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>2. Kaleidoscope: Implementing a Parser and AST | LiTong&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="2.1. Chapter 2 Introduction欢迎来到”用LLVM实现一门程序语言“教程第2章。这一节会展示如何基于Chapter 1构造的词法分析器来为Kaleidoscope语言构造一个完整的语法分析器。完成语法分析器后，我们将定义并构造抽象语法树 （AST）。">
<meta name="keywords" content="LLVM Tutorial">
<meta property="og:type" content="article">
<meta property="og:title" content="2. Kaleidoscope: Implementing a Parser and AST">
<meta property="og:url" content="http://yoursite.com/2018/01/10/2-Kaleidoscope-Implementing-a-Parser-and-AST/index.html">
<meta property="og:site_name" content="LiTong&#39;s Blog">
<meta property="og:description" content="2.1. Chapter 2 Introduction欢迎来到”用LLVM实现一门程序语言“教程第2章。这一节会展示如何基于Chapter 1构造的词法分析器来为Kaleidoscope语言构造一个完整的语法分析器。完成语法分析器后，我们将定义并构造抽象语法树 （AST）。">
<meta property="og:locale" content="zh">
<meta property="og:updated_time" content="2018-01-11T08:00:55.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2. Kaleidoscope: Implementing a Parser and AST">
<meta name="twitter:description" content="2.1. Chapter 2 Introduction欢迎来到”用LLVM实现一门程序语言“教程第2章。这一节会展示如何基于Chapter 1构造的词法分析器来为Kaleidoscope语言构造一个完整的语法分析器。完成语法分析器后，我们将定义并构造抽象语法树 （AST）。">
  
    <link rel="alternate" href="/atom.xml" title="LiTong&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiTong&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2-Kaleidoscope-Implementing-a-Parser-and-AST" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/10/2-Kaleidoscope-Implementing-a-Parser-and-AST/" class="article-date">
  <time datetime="2018-01-10T07:46:33.000Z" itemprop="datePublished">2018-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      2. Kaleidoscope: Implementing a Parser and AST
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="2-1-Chapter-2-Introduction"><a href="#2-1-Chapter-2-Introduction" class="headerlink" title="2.1. Chapter 2 Introduction"></a>2.1. Chapter 2 Introduction</h2><p>欢迎来到”用LLVM实现一门程序语言“教程第2章。这一节会展示如何基于Chapter 1构造的词法分析器来为Kaleidoscope语言构造一个完整的<a href="http://en.wikipedia.org/wiki/Parsing" target="_blank" rel="noopener">语法分析器</a>。完成语法分析器后，我们将定义并构造<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">抽象语法树</a> （AST）。</p>
<a id="more"></a>
<!--
Welcome to Chapter 2 of the “[Implementing a language with LLVM](http://llvm.org/docs/tutorial/index.html)” tutorial. This chapter shows you how to use the lexer, built in [Chapter 1](http://llvm.org/docs/tutorial/LangImpl01.html), to build a full parser for our Kaleidoscope language. Once we have a [parser](http://en.wikipedia.org/wiki/Parsing), we’ll define and build an [Abstract Syntax Tree](http://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST).
-->
<p>我们将结合<a href="http://en.wikipedia.org/wiki/Recursive_descent_parser" target="_blank" rel="noopener">Recursive Descent Parsing</a>与<a href="http://en.wikipedia.org/wiki/Operator-precedence_parser" target="_blank" rel="noopener">Operator-Precedence Parsing </a>来对Kaleidoscope语言进行语法分析（后一个规则用于二元运算表达式，前一个规则用于其余所有情况）。在开始语法分析前，让我们先讨论一下语法分析器的输出：抽象语法树。</p>
<!--
The parser we will build uses a combination of [Recursive Descent Parsing](http://en.wikipedia.org/wiki/Recursive_descent_parser) and [Operator-Precedence Parsing ](http://en.wikipedia.org/wiki/Operator-precedence_parser)to parse the Kaleidoscope language (the latter for binary expressions and the former for everything else). Before we get to parsing though, lets talk about the output of the parser: the Abstract Syntax Tree.
-->
<h2 id="2-2-The-Abstract-Syntax-Tree-AST"><a href="#2-2-The-Abstract-Syntax-Tree-AST" class="headerlink" title="2.2. The Abstract Syntax Tree (AST)"></a>2.2. The Abstract Syntax Tree (AST)</h2><p>一个程序的AST会捕捉该程序的行为，并用一种方便编译器后续阶段（比如说code generation阶段）理解和处理的方式表达出来。我们希望语言中的每次construct都对应一个object，AST应该尽可能精确地对该语言进行建模。在<code>Kaleidoscope</code>中，我们有一些表达式，一个原型，以及一个函数object。我们从表达式开始：</p>
<!-- 原文：
The AST for a program captures its behavior in such a way that it is easy for later stages of the compiler (e.g. code generation) to interpret. We basically want one object for each construct in the language, and the AST should closely model the language. In Kaleidoscope, we have expressions, a prototype, and a function object. We’ll start with expressions first 
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprAST</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~ExprAST() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NumberExprAST - Expression class for numeric literals like "1.0".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NumberExprAST(<span class="keyword">double</span> Val) : Val(Val) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码展示了<code>ExprAST</code>基类，以及一个用于表示数字常量的子类。值得注意的是<code>NumberExprAST</code>类将数字常量的数值存储为变量，这让编译器后面的阶段可以知道存储的数字常量的值。</p>
<!-- comment 原文：
The code above shows the definition of the base ExprAST class and one subclass which we use for numeric literals. The important thing to note about this code is that the NumberExprAST class captures the numeric value of the literal as an instance variable. This allows later phases of the compiler to know what the stored numeric value is.
-->
<p>现在我们只构造了AST，并没有有效的读写访问函数。可以很方便地增加一个虚函数来实现这些功能，比如说，可以打印出代码。下面是一些其他的AST节点定义，我们会在<code>Kaleidoscope</code>语言的基本格式中用到：</p>
<!-- comment 原文：
Right now we only create the AST, so there are no useful accessor methods on them. It would be very easy to add a virtual method to pretty print the code, for example. Here are the other expression AST node definitions that we’ll use in the basic form of the Kaleidoscope language:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// VariableExprAST - Expression class for referencing a variable, like "a".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  VariableExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Name) : Name(Name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinaryExprAST - Expression class for a binary operator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">char</span> Op;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS, RHS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  BinaryExprAST(<span class="keyword">char</span> op, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS,</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; RHS)</span><br><span class="line">    : Op(op), LHS(<span class="built_in">std</span>::move(LHS)), RHS(<span class="built_in">std</span>::move(RHS)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CallExprAST - Expression class for function calls.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Callee;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  CallExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Callee,</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args)</span><br><span class="line">    : Callee(Callee), Args(<span class="built_in">std</span>::move(Args)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些都并不直观：变量保存着变量名，二元运算符保存着它们的运算符(比如：’+’)，调用保存callee的函数名，以及参数表达式的列表。AST的一个优点在于，它可以在不涉及语言的句法的前提下，表述语言的特点。要注意，这里没有讨论运算符优先级、lexcial structure等问题。</p>
<!--
This is all (intentionally) rather straight-forward: variables capture the variable name, binary operators capture their opcode (e.g. ‘+’), and calls capture a function name as well as a list of any argument expressions. One thing that is nice about our AST is that it captures the language features without talking about the syntax of the language. Note that there is no discussion about precedence of binary operators, lexical structure, etc
-->
<p>对于我们基本的程序语言来说，这些都是我们需要定义的表达式节点。因为还没有条件控制流，所以我们还没有结束，在后面的小节里会补充上。我们现在要做两件事：怎样描述函数借口，以及怎样描述函数本身。</p>
<!--
For our basic language, these are all of the expression nodes we’ll define. Because it doesn’t have conditional control flow, it isn’t Turing-complete; we’ll fix that in a later installment. The two things we need next are a way to talk about the interface to a function, and a way to talk about functions themselves:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// PrototypeAST - This class represents the "prototype" for a function,</span></span><br><span class="line"><span class="comment">/// which captures its name, and its argument names (thus implicitly the number</span></span><br><span class="line"><span class="comment">/// of arguments the function takes).</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PrototypeAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args)</span><br><span class="line">    : Name(name), Args(<span class="built_in">std</span>::move(Args)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// FunctionAST - This class represents a function definition itself.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  FunctionAST(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto,</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body)</span><br><span class="line">    : Proto(<span class="built_in">std</span>::move(Proto)), Body(<span class="built_in">std</span>::move(Body)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Kaleidoscope语言中，函数的输入只伴随着一列参数。因为所有的变量都是双精度浮点型，所以不需要存储变量类型。在更aggressive和realistic的语言中，<code>ExprAST</code>类需要一个type域。</p>
<!--
In Kaleidoscope, functions are typed with just a count of their arguments. Since all values are double precision floating point, the type of each argument doesn’t need to be stored anywhere. In a more aggressive and realistic language, the “ExprAST” class would probably have a type field.
->

有了这些基本的工具，我们可以开始讨论语法表达式，以及Kaleidoscope中的函数体了。

<!--
With this scaffolding, we can now talk about parsing expressions and function bodies in Kaleidoscope.
-->
<h2 id="2-3-Parser-Basics"><a href="#2-3-Parser-Basics" class="headerlink" title="2.3. Parser Basics"></a>2.3. Parser Basics</h2><p>现在我们需要定义一个语法分析程序去构造AST。基本的idea是对类似于”x+y“(词法分析会返回3个token)的东西进行语法分析，通过类似于下面的calls转换成AST：</p>
<!--
Now that we have an AST to build, we need to define the parser code to build it. The idea here is that we want to parse something like “x+y” (which is returned as three tokens by the lexer) into an AST that could be generated with calls like this:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> LHS = llvm::make_unique&lt;VariableExprAST&gt;(<span class="string">"x"</span>);</span><br><span class="line"><span class="keyword">auto</span> RHS = llvm::make_unique&lt;VariableExprAST&gt;(<span class="string">"y"</span>);</span><br><span class="line"><span class="keyword">auto</span> Result = <span class="built_in">std</span>::make_unique&lt;BinaryExprAST&gt;(<span class="string">'+'</span>, <span class="built_in">std</span>::move(LHS),</span><br><span class="line">                                              <span class="built_in">std</span>::move(RHS));</span><br></pre></td></tr></table></figure>
<p>为了做到这一点，我们需要定义一些基本的功能代码块：</p>
<!--
In order to do this, we’ll start by defining some basic helper routines:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current</span></span><br><span class="line"><span class="comment">/// token the parser is looking at.  getNextToken reads another token from the</span></span><br><span class="line"><span class="comment">/// lexer and updates CurTok with its results.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> CurTok;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> CurTok = gettok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码实现了一个简单的token buffer。它可以从词法分析的结果中获取下一个token。语法分析的所有函数都假设<code>CurTok</code>是当前需要进行语法分析的token。</p>
<!--
This implements a simple token buffer around the lexer. This allows us to look one token ahead at what the lexer is returning. Every function in our parser will assume that CurTok is the current token that needs to be parsed.
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// LogError* - These are little helper functions for error handling.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LogError(<span class="keyword">const</span> <span class="keyword">char</span> *Str) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"LogError: %s\n"</span>, Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; LogErrorP(<span class="keyword">const</span> <span class="keyword">char</span> *Str) &#123;</span><br><span class="line">  LogError(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LogError</code>这部分的代码在我们语法分析器中用于处理errors，我们语法分析器中的error恢复部分并不是最好的，也并不user-friendly，但对于tutorial足够了。这些代码使得有不同返回类型的代码路径处理errors变得更简单：它们总是返回null。</p>
<!--
The `LogError` routines are simple helper routines that our parser will use to handle errors. The error recovery in our parser will not be the best and is not particular user-friendly, but it will be enough for our tutorial. These routines make it easier to handle errors in routines that have various return types: they always return null.
-->
<p>有了这些基本的函数，我们可以实现我们算法的第一部分：数字字面量。</p>
<!--
With these basic helper functions, we can implement the first piece of our grammar: numeric literals.
-->
<h2 id="2-4-Basic-Expression-Parsing"><a href="#2-4-Basic-Expression-Parsing" class="headerlink" title="2.4. Basic Expression Parsing"></a>2.4. Basic Expression Parsing</h2><p>因为数字字面量是最容易处理的，所以我们从它开始。对于语法中的每种production，我们都会定义一个函数来对它进行语法分析。处理数字字面量的函数如下：</p>
<!--
We start with numeric literals, because they are the simplest to process. For each production in our grammar, we’ll define a function which parses that production. For numeric literals, we have:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// numberexpr ::= number</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseNumberExpr() &#123;</span><br><span class="line">  <span class="keyword">auto</span> Result = llvm::make_unique&lt;NumberExprAST&gt;(NumVal);</span><br><span class="line">  getNextToken(); <span class="comment">// consume the number</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(Result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码非常简单：它在当前token是<code>tok_number</code>时被调用。它读取当前数字的值，创建一个<code>NumberExprAST</code>节点，让词法分析器读取下一个token，然后返回。</p>
<!--
This routine is very simple: it expects to be called when the current token is a `tok_number` token. It takes the current number value, creates a `NumberExprAST` node, advances the lexer to the next token, and finally returns.
-->
<p>这里有一些有意思的点，其中最重要的一点是这些代码都会读取当前production的所有tokens，并且读取词法分析器的下一个要处理token存在buffer中（这个token不属于当前的语法production）。这是recursive descent parsers中比较常规的方法。圆括号操作符的定义是一个更好的例子，代码如下：</p>
<!--
There are some interesting aspects to this. The most important one is that this routine eats all of the tokens that correspond to the production and returns the lexer buffer with the next token (which is not part of the grammar production) ready to go. This is a fairly standard way to go for recursive descent parsers. For a better example, the parenthesis operator is defined like this:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// parenexpr ::= '(' expression ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseParenExpr() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat (.</span></span><br><span class="line">  <span class="keyword">auto</span> V = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected ')'"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat ).</span></span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数展示了语法分析器有意思的几个地方：</p>
<!--
This function illustrates a number of interesting things about the parser:
-->
<p>1）它向我们展示了如何使用LogError。这个函数被调用时，当前的token是’(‘，分析完子表达式后，应该有一个’)’。比如说，如果用户输入”(4 x”，而不是”(4)”，那么语法分析器就应该报错。语法分析器需要一种方式，来指出哪里发生了错误：在我们的语法分析器中，出错时会返回null。</p>
<!--
1) It shows how we use the LogError routines. When called, this function expects that the current token is a ‘(‘ token, but after parsing the subexpression, it is possible that there is no ‘)’ waiting. For example, if the user types in “(4 x” instead of “(4)”, the parser should emit an error. Because errors can occur, the parser needs a way to indicate that they happened: in our parser, we return null on an error.
-->
<p>2）另一个有意思的地方是这个函数通过调用<code>ParseExpression</code>来递归调用（稍后我们会看到<code>ParseExpression</code>可以调用<code>ParseParenExpr</code>）。这一点很powerful，因为它可以处理递归语法，让每个production都比较simple。注意圆括号本身并不创建AST节点，圆括号最重要的功能是指导语法分析，并提供分组。一旦语法分析器构造好了AST，就不再需要圆括号了。</p>
<!--
2) Another interesting aspect of this function is that it uses recursion by calling `ParseExpression` (we will soon see that `ParseExpression` can call `ParseParenExpr`). This is powerful because it allows us to handle recursive grammars, and keeps each production very simple. Note that parentheses do not cause construction of AST nodes themselves. While we could do it this way, the most important role of parentheses are to guide the parser and provide grouping. Once the parser constructs the AST, parentheses are not needed.
-->
<p>下一个production用来处理变量引用，以及函数调用：</p>
<!--
The next simple production is for handling variable references and function calls:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= identifier</span></span><br><span class="line"><span class="comment">///   ::= identifier '(' expression* ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseIdentifierExpr() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> IdName = IdentifierStr;</span><br><span class="line"></span><br><span class="line">  getNextToken();  <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>) <span class="comment">// Simple variable ref.</span></span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;VariableExprAST&gt;(IdName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call.</span></span><br><span class="line">  getNextToken();  <span class="comment">// eat (</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Arg = ParseExpression())</span><br><span class="line">        Args.push_back(<span class="built_in">std</span>::move(Arg));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok == <span class="string">')'</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok != <span class="string">','</span>)</span><br><span class="line">        <span class="keyword">return</span> LogError(<span class="string">"Expected ')' or ',' in argument list"</span>);</span><br><span class="line">      getNextToken();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eat the ')'.</span></span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;CallExprAST&gt;(IdName, <span class="built_in">std</span>::move(Args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的风格和之前的代码一样（这段代码在当前token是<code>tok_identifier</code>时被调用）。这段代码同样有递归调用和错误处理部分。一个有意思的地方是，这段代码通过<em>look-ahead</em>的方法来判定当前的标识符是一个变量的引用还是一个函数调用。具体来说，就是往前多读一个token，看这个token是不是’(‘，如果不是，构造<code>VariableExprAST</code>节点；如果是，构造<code>CallExprAST</code>节点。现在，我们有了简单的对表达式进行语法分析的代码，可以把它们包装在一个函数中，这样就可以通过一个入口来进行语法分析。我们把这类表达式称为”primary”表达式，原因会在<a href="http://llvm.org/docs/tutorial/LangImpl6.html#user-defined-unary-operators" target="_blank" rel="noopener">后面的章节</a>里说明。为了对任意primary表达式进行语法分析，我们需要定义表达式的排序：</p>
<!--
This routine follows the same style as the other routines. (It expects to be called if the current token is a `tok_identifier` token). It also has recursion and error handling. One interesting aspect of this is that it uses *look-ahead* to determine if the current identifier is a stand alone variable reference or if it is a function call expression. It handles this by checking to see if the token after the identifier is a ‘(‘ token, constructing either a `VariableExprAST` or `CallExprAST` node as appropriate.
Now that we have all of our simple expression-parsing logic in place, we can define a helper function to wrap it together into one entry point. We call this class of expressions “primary” expressions, for reasons that will become more clear [later in the tutorial](http://llvm.org/docs/tutorial/LangImpl6.html#user-defined-unary-operators). In order to parse an arbitrary primary expression, we need to determine what sort of expression it is:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// primary</span></span><br><span class="line"><span class="comment">///   ::= identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= numberexpr</span></span><br><span class="line"><span class="comment">///   ::= parenexpr</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParsePrimary() &#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"unknown token when expecting an expression"</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> ParseIdentifierExpr();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> ParseNumberExpr();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">    <span class="keyword">return</span> ParseParenExpr();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到上面这个函数后，你就更清楚我们为何可以在不同的函数中对CurTok进行假设。这段代码通过look-ahead来决定表达式检查的顺序，然后通过函数调用来对其进行语法分析。</p>
<!--
Now that you see the definition of this function, it is more obvious why we can assume the state of CurTok in the various functions. This uses look-ahead to determine which sort of expression is being inspected, and then parses it with a function call.
-->
<p>现在基本的表达式已经可以处理了，下面需要处理二元运算表达式了，这会稍微复杂点。</p>
<!--
Now that basic expressions are handled, we need to handle binary expressions. They are a bit more complex.
-->
<h2 id="2-5-Binary-Expressions-Parsing"><a href="#2-5-Binary-Expressions-Parsing" class="headerlink" title="2.5. Binary Expressions Parsing"></a>2.5. Binary Expressions Parsing</h2><p>对二元表达式进行语法分析比较困难，因为它们通常都有多种含义。举例来说，对于“x+y*z”，语法分析器需要选择将它翻译成“(x+y)*z”还是“x+(y*z)”。根据数学知识，我们期望得到后面一种结果，因为乘法的优先级比加法高。</p>
<!--
Binary expressions are significantly harder to parse because they are often ambiguous. For example, when given the string “x+y\*z”, the parser can choose to parse it as either “(x+y)\*z” or “x+(y\*z)”. With common definitions from mathematics, we expect the later parse, because “*” (multiplication) has higher precedence than “+” (addition).
-->
<p>有很多方法可以处理这件事，但是一个优雅且高效的方法是使用<a href="http://en.wikipedia.org/wiki/Operator-precedence_parser" target="_blank" rel="noopener">运算符优先语法分析</a>。这个技术使用二元运算符的优先级来指导递归调用。首先，我们需要一张优先级顺序表：</p>
<!--
There are many ways to handle this, but an elegant and efficient way is to use [Operator-Precedence Parsing](http://en.wikipedia.org/wiki/Operator-precedence_parser). This parsing technique uses the precedence of binary operators to guide recursion. To start with, we need a table of precedences:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// BinopPrecedence - This holds the precedence for each binary operator that is</span></span><br><span class="line"><span class="comment">/// defined.</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; BinopPrecedence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// GetTokPrecedence - Get the precedence of the pending binary operator token.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetTokPrecedence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isascii(CurTok))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure it's a declared binop.</span></span><br><span class="line">  <span class="keyword">int</span> TokPrec = BinopPrecedence[CurTok];</span><br><span class="line">  <span class="keyword">if</span> (TokPrec &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> TokPrec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">'&lt;'</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'+'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'-'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'*'</span>] = <span class="number">40</span>;  <span class="comment">// highest.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在简单版的Kaleidoscope语言中，我们只支持4个二元运算符（当然你可以进行扩展）。<code>GetTokPrecedence</code>函数返回当前token的优先级，如果当前token不是二元运算符则返回-1。map容器使增加新的运算符很容易，同时可以看出，这个算法并不依赖于特定的运算符。但是，消除一个map或者在<code>GetTokPrecedence</code>函数中做比较也很容易（或者直接用固定大小的数组）。</p>
<!--
For the basic form of Kaleidoscope, we will only support 4 binary operators (this can obviously be extended by you, our brave and intrepid reader). The `GetTokPrecedence` function returns the precedence for the current token, or -1 if the token is not a binary operator. Having a map makes it easy to add new operators and makes it clear that the algorithm doesn’t depend on the specific operators involved, but it would be easy enough to eliminate the map and do the comparisons in the `GetTokPrecedence` function. (Or just use a fixed-size array).
-->
<p>有了上面的代码，我们现在可以开始对二元表达式进行语法分析了。运算符有限语法分析的基本思路是按照可能有多义的二元运算符，将表达式拆成几个部分。用“a+b+(c+d)*e*f+g”表达式举例来说，运算符优先语法分析会将这个表达式看做被二元运算符分割开的primary expressions流。这样一来，它会首先对primary expression “a”进行语法分析，然后会看到[+, b] [+, (c+d)] [<em>, e] [</em>, f] and [+, g]。注意，因为圆括号属于primary expressions，二元表达式的语法分析不需要考虑类似于(c+d)的嵌套子表达式。</p>
<!--
With the helper above defined, we can now start parsing binary expressions. The basic idea of operator precedence parsing is to break down an expression with potentially ambiguous binary operators into pieces. Consider, for example, the expression “a+b+(c+d)\*e\*f+g”. Operator precedence parsing considers this as a stream of primary expressions separated by binary operators. As such, it will first parse the leading primary expression “a”, then it will see the pairs [+, b] [+, (c+d)] [*, e] [*, f] and [+, g]. Note that because parentheses are primary expressions, the binary expression parser doesn’t need to worry about nested subexpressions like (c+d) at all.
-->
<p>To start, an expression is a primary expression potentially followed by a sequence of [binop,primaryexpr] pairs:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// expression</span></span><br><span class="line"><span class="comment">///   ::= primary binoprhs</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseExpression() &#123;</span><br><span class="line">  <span class="keyword">auto</span> LHS = ParsePrimary();</span><br><span class="line">  <span class="keyword">if</span> (!LHS)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ParseBinOpRHS(<span class="number">0</span>, <span class="built_in">std</span>::move(LHS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ParseBinOpRHS</code>函数为我们对这一列的pairs进行语法分析。函数中有一个指针，指向表达式中目前分析到的部分。注意，”x”是一个合法的表达式，也就是说，”binoprhs”允许为空，这种情况下直接把输入的表达式返回。在上面的例子中，代码将表达式”a”作为参数传入<code>ParseBinOpRHS</code>，然后当前token为”+”。</p>
<!--
`ParseBinOpRHS` is the function that parses the sequence of pairs for us. It takes a precedence and a pointer to an expression for the part that has been parsed so far. Note that “x” is a perfectly valid expression: As such, “binoprhs” is allowed to be empty, in which case it returns the expression that is passed into it. In our example above, the code passes the expression for “a” into `ParseBinOpRHS` and the current token is “+”.
-->
<p>传入<code>ParseBinOpRHS</code>的优先级数值表明了这个函数可以读取的<em>最低运算符优先级</em>。举例来说，如果当前的pair stream是[+, x]，<code>ParseBinOpRHS</code>中传入的优先级是40，那么它就不处理任何tokens（因为’+’的优先级仅为20）。根据这个原则，<code>ParseBinOpRHS</code>的代码开头如下：</p>
<!--
The precedence value passed into `ParseBinOpRHS` indicates the *minimal operator precedence* that the function is allowed to eat. For example, if the current pair stream is [+, x] and `ParseBinOpRHS` is passed in a precedence of 40, it will not consume any tokens (because the precedence of ‘+’ is only 20). With this in mind, `ParseBinOpRHS` starts with:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// binoprhs</span></span><br><span class="line"><span class="comment">///   ::= ('+' primary)*</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseBinOpRHS(<span class="keyword">int</span> ExprPrec,</span><br><span class="line">                                              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS) &#123;</span><br><span class="line">  <span class="comment">// If this is a binop, find its precedence.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> TokPrec = GetTokPrecedence();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a binop that binds at least as tightly as the current binop,</span></span><br><span class="line">    <span class="comment">// consume it, otherwise we are done.</span></span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; ExprPrec)</span><br><span class="line">      <span class="keyword">return</span> LHS;</span><br></pre></td></tr></table></figure>
<p>这段代码会获取当前token的优先级，并检测它的值是否太小。因为我们定义不合法的tokens会返回优先级为-1，这样就使得pair-stream在token stream跑完所有二元运算符后结束。如果检查成功，我们就知道这个token是一个二元运算符，并且会被包含在这个表达式中：</p>
<!--
This code gets the precedence of the current token and checks to see if it is too low. Because we defined invalid tokens to have a precedence of -1, this check implicitly knows that the pair-stream ends when the token stream runs out of binary operators. If this check succeeds, we know that the token is a binary operator and that it will be included in this expression:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Okay, we know this is a binop.</span></span><br><span class="line"><span class="keyword">int</span> BinOp = CurTok;</span><br><span class="line">getNextToken();  <span class="comment">// eat binop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse the primary expression after the binary operator.</span></span><br><span class="line"><span class="keyword">auto</span> RHS = ParsePrimary();</span><br><span class="line"><span class="keyword">if</span> (!RHS)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>这段代码读取了二元运算符，然后对后面跟着的primary expression进行语法分析。这样就够早了全部的pair，对于我们的例子来说，第一个pair就是[+, b]。</p>
<!--
As such, this code eats (and remembers) the binary operator and then parses the primary expression that follows. This builds up the whole pair, the first of which is [+, b] for the running example.
-->
<p>现在我们对表达式的左边，以及RHS序列的一个pair，进行了语法分析，现在我们需要决定表达式应该按照哪种方式来组织。举例来说，我们可以选择”(a+b) binop unparsed”，或者”a + (b binop unparsed)”。为此，我们需要往前看”binop”，来决定它的优先级，and compare it to BinOp’s precedence (which is ‘+’ in this case):</p>
<!--
Now that we parsed the left-hand side of an expression and one pair of the RHS sequence, we have to decide which way the expression associates. In particular, we could have “(a+b) binop unparsed” or “a + (b binop unparsed)”. To determine this, we look ahead at “binop” to determine its precedence and compare it to BinOp’s precedence (which is ‘+’ in this case):
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If BinOp binds less tightly with RHS than the operator after RHS, let</span></span><br><span class="line"><span class="comment">// the pending operator take RHS as its LHS.</span></span><br><span class="line"><span class="keyword">int</span> NextPrec = GetTokPrecedence();</span><br><span class="line"><span class="keyword">if</span> (TokPrec &lt; NextPrec) &#123;</span><br></pre></td></tr></table></figure>
<p>如果右边”RHS”的binop的优先级小于或等于当前运算符的优先级，我们可以判定圆括号应该被处理为”(a+b) binop …”。在我们的例子中，当前运算符是”+”，下一个运算符也是”+”，它们有相同的优先级。在这种情况下我们会在AST中创建”a+b”节点，然后继续进行语法分析：</p>
<!--
If the precedence of the binop to the right of “RHS” is lower or equal to the precedence of our current operator, then we know that the parentheses associate as “(a+b) binop ...”. In our example, the current operator is “+” and the next operator is “+”, we know that they have the same precedence. In this case we’ll create the AST node for “a+b”, and then continue parsing:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      ... <span class="keyword">if</span> body omitted ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge LHS/RHS.</span></span><br><span class="line">    LHS = llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, <span class="built_in">std</span>::move(LHS),</span><br><span class="line">                                           <span class="built_in">std</span>::move(RHS));</span><br><span class="line">  &#125;  <span class="comment">// loop around to the top of the while loop.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，”a+b”会被转换为”(a+b)”，然后进入下一循环。上面的代码会将”(c+d)”作为primary expression，进行语法分析，让当前的pair为[+, (c+d)]。之后它会判断上面提到的if条件with “*” as the binop to the right of the primary。在这种情况下，”*“的优先级高于”+”的优先级，所以会进入if为真的语句。</p>
<!--
In our example above, this will turn “a+b+” into “(a+b)” and execute the next iteration of the loop, with “+” as the current token. The code above will eat, remember, and parse “(c+d)” as the primary expression, which makes the current pair equal to [+, (c+d)]. It will then evaluate the ‘if’ conditional above with “\*” as the binop to the right of the primary. In this case, the precedence of “\*” is higher than the precedence of “+” so the if condition will be entered.
-->
<p>还有一个遗留的重要问题是“how can the if condition parse the right hand side in full”？在我们的例子中，为了正确构造AST，需要获得”(c+d)*e*f”作为RHS表达式。实现这个功能的代码却非常简单（从上面两个代码块复制下来的）：</p>
<!--
The critical question left here is “how can the if condition parse the right hand side in full”? In particular, to build the AST correctly for our example, it needs to get all of “(c+d)\*e\*f” as the RHS expression variable. The code to do this is surprisingly simple (code from the above two blocks duplicated for context):
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// If BinOp binds less tightly with RHS than the operator after RHS, let</span></span><br><span class="line">    <span class="comment">// the pending operator take RHS as its LHS.</span></span><br><span class="line">    <span class="keyword">int</span> NextPrec = GetTokPrecedence();</span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; NextPrec) &#123;</span><br><span class="line">      RHS = ParseBinOpRHS(TokPrec+<span class="number">1</span>, <span class="built_in">std</span>::move(RHS));</span><br><span class="line">      <span class="keyword">if</span> (!RHS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Merge LHS/RHS.</span></span><br><span class="line">    LHS = llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, <span class="built_in">std</span>::move(LHS),</span><br><span class="line">                                           <span class="built_in">std</span>::move(RHS));</span><br><span class="line">  &#125;  <span class="comment">// loop around to the top of the while loop.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们知道了the binary operator to the RHS of our primary比我们当前处理的binop的优先级更高。这样一来，所有优先级比”+”高的pairs都会进行语法分析，作为”RHS”返回。为了做到这一点，我们循环调用<code>ParseBinOpRHS</code>函数，并将”TokPrec+1”作为最小优先级。在我们的例子中，会返回”(c+d)*e*f”作为RHS，然后将RHS设为”+”表达式。</p>
<!--
At this point, we know that the binary operator to the RHS of our primary has higher precedence than the binop we are currently parsing. As such, we know that any sequence of pairs whose operators are all higher precedence than “+” should be parsed together and returned as “RHS”. To do this, we recursively invoke the `ParseBinOpRHS` function specifying “TokPrec+1” as the minimum precedence required for it to continue. In our example above, this will cause it to return the AST node for “(c+d)\*e\*f” as RHS, which is then set as the RHS of the ‘+’ expression.
-->
<p>最后，在while循环的下一次迭代中，会对”+g”进行语法分析，并添加到AST中。我们只用了很少的代码（14行）就完整处理了对二元表达式进行语法分析的工作，非常优雅。这里只是对代码的一个粗略的浏览，有的地方还欠缺考虑。我们推荐你用一些比较难的样例去测试，看是否work。</p>
<!--
Finally, on the next iteration of the while loop, the “+g” piece is parsed and added to the AST. With this little bit of code (14 non-trivial lines), we correctly handle fully general binary expression parsing in a very elegant way. This was a whirlwind tour of this code, and it is somewhat subtle. I recommend running through it with a few tough examples to see how it works.
-->
<p>这些就是对处理表达式的代码。现在，我们可以对任意token串进行语法分析，并从中构造表达式。接下来我们要处理函数定义等部分。</p>
<p> &lt;–<br>This wraps up handling of expressions. At this point, we can point the parser at an arbitrary token stream and build an expression from it, stopping at the first token that is not part of the expression. Next up we need to handle function definitions, etc.<br>–&gt;</p>
<h2 id="2-6-Parsing-the-Rest"><a href="#2-6-Parsing-the-Rest" class="headerlink" title="2.6. Parsing the Rest"></a>2.6. Parsing the Rest</h2><p>接下来的事情是处理函数原型。在Kaleidoscope中，它们被用在’extern’函数和函数体定义中。做这件事的代码很直观，not interesting：</p>
<!--
The next thing missing is handling of function prototypes. In Kaleidoscope, these are used both for ‘extern’ function declarations as well as function body definitions. The code to do this is straight-forward and not very interesting (once you’ve survived expressions):
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///   ::= id '(' id* ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParsePrototype() &#123;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected function name in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> FnName = IdentifierStr;</span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected '(' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read the list of argument names.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ArgNames;</span><br><span class="line">  <span class="keyword">while</span> (getNextToken() == tok_identifier)</span><br><span class="line">    ArgNames.push_back(IdentifierStr);</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected ')' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// success.</span></span><br><span class="line">  getNextToken();  <span class="comment">// eat ')'.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;PrototypeAST&gt;(FnName, <span class="built_in">std</span>::move(ArgNames));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，函数定义就很简单了，一个函数原型加上函数体表达式的实现：</p>
<!--
Given this, a function definition is very simple, just a prototype plus an expression to implement the body:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// definition ::= 'def' prototype expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; ParseDefinition() &#123;</span><br><span class="line">  getNextToken();  <span class="comment">// eat def.</span></span><br><span class="line">  <span class="keyword">auto</span> Proto = ParsePrototype();</span><br><span class="line">  <span class="keyword">if</span> (!Proto) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = ParseExpression())</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto), <span class="built_in">std</span>::move(E));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，我们支持’extern’定义函数，比如’sin’、’cos’等，我们也支持<a href="http://www.learncpp.com/cpp-tutorial/19-header-files/" target="_blank" rel="noopener">前置声明</a>，这些’extern’只是原型，没有函数体。</p>
<!--
In addition, we support ‘extern’ to declare functions like ‘sin’ and ‘cos’ as well as to support forward declaration of user functions. These ‘extern’s are just prototypes with no body:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// external ::= 'extern' prototype</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParseExtern() &#123;</span><br><span class="line">  getNextToken();  <span class="comment">// eat extern.</span></span><br><span class="line">  <span class="keyword">return</span> ParsePrototype();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Finally, we’ll also let the user type in arbitrary top-level expressions and evaluate them on the fly. We will handle this by defining anonymous nullary (zero argument) functions for them:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// toplevelexpr ::= expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; ParseTopLevelExpr() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = ParseExpression()) &#123;</span><br><span class="line">    <span class="comment">// Make an anonymous proto.</span></span><br><span class="line">    <span class="keyword">auto</span> Proto = llvm::make_unique&lt;PrototypeAST&gt;(<span class="string">""</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto), <span class="built_in">std</span>::move(E));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们有了所有的代码片段，可以看是构造一个小的driver，运行我们的代码了！</p>
<!--
Now that we have all the pieces, let’s build a little driver that will let us actually execute this code we’ve built!
-->
<h2 id="2-7-The-Driver"><a href="#2-7-The-Driver" class="headerlink" title="2.7. The Driver"></a>2.7. The Driver</h2><p>这个小的driver只是在顶层做一个循环的分发，根据token类型调用不同的函数。</p>
<!--
The driver for this simply invokes all of the parsing pieces with a top-level dispatch loop. There isn’t much interesting here, so I’ll just include the top-level loop. See below for full code in the “Top-Level Parsing” section.
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// top ::= definition | external | expression | ';'</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ready&gt; "</span>);</span><br><span class="line">    <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">    <span class="keyword">case</span> tok_eof:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">';'</span>: <span class="comment">// ignore top-level semicolons.</span></span><br><span class="line">      getNextToken();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_def:</span><br><span class="line">      HandleDefinition();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_extern:</span><br><span class="line">      HandleExtern();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      HandleTopLevelExpression();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码最有意思的地方在于我们忽略了分号。</p>
<p>The most interesting part of this is that we ignore top-level semicolons. Why is this, you ask? The basic reason is that if you type “4 + 5” at the command line, the parser doesn’t know whether that is the end of what you will type or not. For example, on the next line you could type “def foo…” in which case 4+5 is the end of a top-level expression. Alternatively you could type “* 6”, which would continue the expression. Having top-level semicolons allows you to type “4+5;”, and the parser will know you are done.</p>
<h2 id="2-8-Conclusions"><a href="#2-8-Conclusions" class="headerlink" title="2.8. Conclusions"></a>2.8. Conclusions</h2><p>仅仅用了400行带注释的代码（不带注释和空行的话只需要240行），我们就完成了我们最简化的语言，包含一个词法分析器，一个语法分析器，一个AST构造器。这些做完后，我们就可以执行并验证Kaleidoscope代码，检查语法错误。比如下面的几个简单的交互：</p>
<!--
With just under 400 lines of commented code (240 lines of non-comment, non-blank code), we fully defined our minimal language, including a lexer, parser, and AST builder. With this done, the executable will validate Kaleidoscope code and tell us if it is grammatically invalid. For example, here is a sample interaction:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">ready&gt; def foo(x y) x+foo(y, 4.0);</span><br><span class="line">Parsed a function definition.</span><br><span class="line">ready&gt; def foo(x y) x+y y;</span><br><span class="line">Parsed a function definition.</span><br><span class="line">Parsed a top-level expr</span><br><span class="line">ready&gt; def foo(x y) x+y );</span><br><span class="line">Parsed a function definition.</span><br><span class="line">Error: unknown token when expecting an expression</span><br><span class="line">ready&gt; <span class="function"><span class="keyword">extern</span> <span class="title">sin</span><span class="params">(a)</span></span>;</span><br><span class="line">ready&gt; Parsed an <span class="keyword">extern</span></span><br><span class="line">ready&gt; ^D</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>这里还有很多可以扩展的空间，你可以定义新的AST节点，在很多方面扩展这个语言等等。在下一节，我们会展示如何从AST生成LLVM中间码（IR）。</p>
<!--
There is a lot of room for extension here. You can define new AST nodes, extend the language in many ways, etc. In the [next installment](http://llvm.org/docs/tutorial/LangImpl03.html), we will describe how to generate LLVM Intermediate Representation (IR) from the AST.
-->
<h2 id="2-9-Full-Code-Listing"><a href="#2-9-Full-Code-Listing" class="headerlink" title="2.9. Full Code Listing"></a>2.9. Full Code Listing</h2><p>这里是前两小节的完整代码。这段代码是完全独立的，你不需要LLVM或者任何外部的库，只需要C和C++标准库。你可以用下面的命令build这段代码：</p>
<!--
Here is the complete code listing for this and the previous chapter. Note that it is fully self-contained: you don’t need LLVM or any external libraries at all for this. (Besides the C and C++ standard libraries, of course.) To build this, just compile with:
-->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compile</span></span><br><span class="line">clang++ -g -O3 -std=c++11 toy.cpp</span><br><span class="line"><span class="comment"># Run</span></span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure>
<ul>
<li>译者注1：原文档中的编译命令是<code>clang++ -g -O3 toy.cpp</code>，在Ubuntu 16.04的环境中测试会报出需要使用c++11的选项，需要加上<code>-std=c++11</code>才能顺利编译。</li>
<li>译者注2：”llvm/ADT/STLExtras.h”是必须的，但这就需要LLVM的库函数了，并不像文档里所说的只需要C和C++标注库。</li>
</ul>
<p>下面是代码：</p>
<!--
Here is the code:
-->
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/ADT/STLExtras.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Lexer</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The lexer returns tokens [0-255] if it is an unknown character, otherwise one</span></span><br><span class="line"><span class="comment">// of these for known things.</span></span><br><span class="line"><span class="keyword">enum</span> Token &#123;</span><br><span class="line">  tok_eof = <span class="number">-1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// commands</span></span><br><span class="line">  tok_def = <span class="number">-2</span>,</span><br><span class="line">  tok_extern = <span class="number">-3</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// primary</span></span><br><span class="line">  tok_identifier = <span class="number">-4</span>,</span><br><span class="line">  tok_number = <span class="number">-5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> IdentifierStr; <span class="comment">// Filled in if tok_identifier</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> NumVal;             <span class="comment">// Filled in if tok_number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// gettok - Return the next token from standard input.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gettok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> LastChar = <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip any whitespace.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isspace</span>(LastChar))</span><br><span class="line">    LastChar = getchar();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isalpha</span>(LastChar)) &#123; <span class="comment">// identifier: [a-zA-Z][a-zA-Z0-9]*</span></span><br><span class="line">    IdentifierStr = LastChar;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalnum</span>((LastChar = getchar())))</span><br><span class="line">      IdentifierStr += LastChar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"def"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_def;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">"extern"</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_extern;</span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">'.'</span>) &#123; <span class="comment">// Number: [0-9.]+</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> NumStr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      NumStr += LastChar;</span><br><span class="line">      LastChar = getchar();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    NumVal = strtod(NumStr.c_str(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> tok_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (LastChar == <span class="string">'#'</span>) &#123;</span><br><span class="line">    <span class="comment">// Comment until end of line.</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      LastChar = getchar();</span><br><span class="line">    <span class="keyword">while</span> (LastChar != EOF &amp;&amp; LastChar != <span class="string">'\n'</span> &amp;&amp; LastChar != <span class="string">'\r'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LastChar != EOF)</span><br><span class="line">      <span class="keyword">return</span> gettok();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for end of file.  Don't eat the EOF.</span></span><br><span class="line">  <span class="keyword">if</span> (LastChar == EOF)</span><br><span class="line">    <span class="keyword">return</span> tok_eof;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, just return the character as its ascii value.</span></span><br><span class="line">  <span class="keyword">int</span> ThisChar = LastChar;</span><br><span class="line">  LastChar = getchar();</span><br><span class="line">  <span class="keyword">return</span> ThisChar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Abstract Syntax Tree (aka Parse Tree)</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprAST</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~ExprAST() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NumberExprAST - Expression class for numeric literals like "1.0".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NumberExprAST(<span class="keyword">double</span> Val) : Val(Val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// VariableExprAST - Expression class for referencing a variable, like "a".</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  VariableExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Name) : Name(Name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinaryExprAST - Expression class for a binary operator.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="keyword">char</span> Op;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS, RHS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  BinaryExprAST(<span class="keyword">char</span> Op, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS,</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; RHS)</span><br><span class="line">      : Op(Op), LHS(<span class="built_in">std</span>::move(LHS)), RHS(<span class="built_in">std</span>::move(RHS)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CallExprAST - Expression class for function calls.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Callee;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  CallExprAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Callee,</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args)</span><br><span class="line">      : Callee(Callee), Args(<span class="built_in">std</span>::move(Args)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// PrototypeAST - This class represents the "prototype" for a function,</span></span><br><span class="line"><span class="comment">/// which captures its name, and its argument names (thus implicitly the number</span></span><br><span class="line"><span class="comment">/// of arguments the function takes).</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> Name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PrototypeAST(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Name, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Args)</span><br><span class="line">      : Name(Name), Args(<span class="built_in">std</span>::move(Args)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// FunctionAST - This class represents a function definition itself.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionAST</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  FunctionAST(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; Proto,</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; Body)</span><br><span class="line">      : Proto(<span class="built_in">std</span>::move(Proto)), Body(<span class="built_in">std</span>::move(Body)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Parser</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current</span></span><br><span class="line"><span class="comment">/// token the parser is looking at.  getNextToken reads another token from the</span></span><br><span class="line"><span class="comment">/// lexer and updates CurTok with its results.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> CurTok;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextToken</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CurTok = gettok(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinopPrecedence - This holds the precedence for each binary operator that is</span></span><br><span class="line"><span class="comment">/// defined.</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; BinopPrecedence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// GetTokPrecedence - Get the precedence of the pending binary operator token.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetTokPrecedence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isascii(CurTok))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure it's a declared binop.</span></span><br><span class="line">  <span class="keyword">int</span> TokPrec = BinopPrecedence[CurTok];</span><br><span class="line">  <span class="keyword">if</span> (TokPrec &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> TokPrec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// LogError* - These are little helper functions for error handling.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LogError(<span class="keyword">const</span> <span class="keyword">char</span> *Str) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: %s\n"</span>, Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; LogErrorP(<span class="keyword">const</span> <span class="keyword">char</span> *Str) &#123;</span><br><span class="line">  LogError(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseExpression();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// numberexpr ::= number</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseNumberExpr() &#123;</span><br><span class="line">  <span class="keyword">auto</span> Result = llvm::make_unique&lt;NumberExprAST&gt;(NumVal);</span><br><span class="line">  getNextToken(); <span class="comment">// consume the number</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(Result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// parenexpr ::= '(' expression ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseParenExpr() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat (.</span></span><br><span class="line">  <span class="keyword">auto</span> V = ParseExpression();</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"expected ')'"</span>);</span><br><span class="line">  getNextToken(); <span class="comment">// eat ).</span></span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= identifier</span></span><br><span class="line"><span class="comment">///   ::= identifier '(' expression* ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseIdentifierExpr() &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> IdName = IdentifierStr;</span><br><span class="line"></span><br><span class="line">  getNextToken(); <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>) <span class="comment">// Simple variable ref.</span></span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;VariableExprAST&gt;(IdName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call.</span></span><br><span class="line">  getNextToken(); <span class="comment">// eat (</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt;&gt; Args;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Arg = ParseExpression())</span><br><span class="line">        Args.push_back(<span class="built_in">std</span>::move(Arg));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok == <span class="string">')'</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok != <span class="string">','</span>)</span><br><span class="line">        <span class="keyword">return</span> LogError(<span class="string">"Expected ')' or ',' in argument list"</span>);</span><br><span class="line">      getNextToken();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eat the ')'.</span></span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;CallExprAST&gt;(IdName, <span class="built_in">std</span>::move(Args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// primary</span></span><br><span class="line"><span class="comment">///   ::= identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= numberexpr</span></span><br><span class="line"><span class="comment">///   ::= parenexpr</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParsePrimary() &#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> LogError(<span class="string">"unknown token when expecting an expression"</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> ParseIdentifierExpr();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> ParseNumberExpr();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">    <span class="keyword">return</span> ParseParenExpr();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// binoprhs</span></span><br><span class="line"><span class="comment">///   ::= ('+' primary)*</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseBinOpRHS(<span class="keyword">int</span> ExprPrec,</span><br><span class="line">                                              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; LHS) &#123;</span><br><span class="line">  <span class="comment">// If this is a binop, find its precedence.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> TokPrec = GetTokPrecedence();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a binop that binds at least as tightly as the current binop,</span></span><br><span class="line">    <span class="comment">// consume it, otherwise we are done.</span></span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; ExprPrec)</span><br><span class="line">      <span class="keyword">return</span> LHS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Okay, we know this is a binop.</span></span><br><span class="line">    <span class="keyword">int</span> BinOp = CurTok;</span><br><span class="line">    getNextToken(); <span class="comment">// eat binop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the primary expression after the binary operator.</span></span><br><span class="line">    <span class="keyword">auto</span> RHS = ParsePrimary();</span><br><span class="line">    <span class="keyword">if</span> (!RHS)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If BinOp binds less tightly with RHS than the operator after RHS, let</span></span><br><span class="line">    <span class="comment">// the pending operator take RHS as its LHS.</span></span><br><span class="line">    <span class="keyword">int</span> NextPrec = GetTokPrecedence();</span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; NextPrec) &#123;</span><br><span class="line">      RHS = ParseBinOpRHS(TokPrec + <span class="number">1</span>, <span class="built_in">std</span>::move(RHS));</span><br><span class="line">      <span class="keyword">if</span> (!RHS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge LHS/RHS.</span></span><br><span class="line">    LHS = llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, <span class="built_in">std</span>::move(LHS),</span><br><span class="line">                                           <span class="built_in">std</span>::move(RHS));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// expression</span></span><br><span class="line"><span class="comment">///   ::= primary binoprhs</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ExprAST&gt; ParseExpression() &#123;</span><br><span class="line">  <span class="keyword">auto</span> LHS = ParsePrimary();</span><br><span class="line">  <span class="keyword">if</span> (!LHS)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ParseBinOpRHS(<span class="number">0</span>, <span class="built_in">std</span>::move(LHS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///   ::= id '(' id* ')'</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParsePrototype() &#123;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected function name in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> FnName = IdentifierStr;</span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">'('</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected '(' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ArgNames;</span><br><span class="line">  <span class="keyword">while</span> (getNextToken() == tok_identifier)</span><br><span class="line">    ArgNames.push_back(IdentifierStr);</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">')'</span>)</span><br><span class="line">    <span class="keyword">return</span> LogErrorP(<span class="string">"Expected ')' in prototype"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// success.</span></span><br><span class="line">  getNextToken(); <span class="comment">// eat ')'.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> llvm::make_unique&lt;PrototypeAST&gt;(FnName, <span class="built_in">std</span>::move(ArgNames));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// definition ::= 'def' prototype expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; ParseDefinition() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat def.</span></span><br><span class="line">  <span class="keyword">auto</span> Proto = ParsePrototype();</span><br><span class="line">  <span class="keyword">if</span> (!Proto)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = ParseExpression())</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto), <span class="built_in">std</span>::move(E));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// toplevelexpr ::= expression</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FunctionAST&gt; ParseTopLevelExpr() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = ParseExpression()) &#123;</span><br><span class="line">    <span class="comment">// Make an anonymous proto.</span></span><br><span class="line">    <span class="keyword">auto</span> Proto = llvm::make_unique&lt;PrototypeAST&gt;(<span class="string">"__anon_expr"</span>,</span><br><span class="line">                                                 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> llvm::make_unique&lt;FunctionAST&gt;(<span class="built_in">std</span>::move(Proto), <span class="built_in">std</span>::move(E));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// external ::= 'extern' prototype</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PrototypeAST&gt; ParseExtern() &#123;</span><br><span class="line">  getNextToken(); <span class="comment">// eat extern.</span></span><br><span class="line">  <span class="keyword">return</span> ParsePrototype();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Top-Level parsing</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ParseDefinition()) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Parsed a function definition.\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ParseExtern()) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Parsed an extern\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleTopLevelExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Evaluate a top-level expression into an anonymous function.</span></span><br><span class="line">  <span class="keyword">if</span> (ParseTopLevelExpr()) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Parsed a top-level expr\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    getNextToken();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// top ::= definition | external | expression | ';'</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ready&gt; "</span>);</span><br><span class="line">    <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">    <span class="keyword">case</span> tok_eof:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">';'</span>: <span class="comment">// ignore top-level semicolons.</span></span><br><span class="line">      getNextToken();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_def:</span><br><span class="line">      HandleDefinition();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_extern:</span><br><span class="line">      HandleExtern();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      HandleTopLevelExpression();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// Main driver code.</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">'&lt;'</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'+'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'-'</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">'*'</span>] = <span class="number">40</span>; <span class="comment">// highest.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prime the first token.</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ready&gt; "</span>);</span><br><span class="line">  getNextToken();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the main "interpreter loop" now.</span></span><br><span class="line">  MainLoop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/10/2-Kaleidoscope-Implementing-a-Parser-and-AST/" data-id="cjcbx21ld0003wp5ikvivyow5" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM-Tutorial/">LLVM Tutorial</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/01/11/3-Kaleidoscope-Code-generation-to-LLVM-IR/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          3. Kaleidoscope: Code generation to LLVM IR
        
      </div>
    </a>
  
  
    <a href="/2018/01/10/1-Kaleidoscope-Tutorial-Introduction-and-the-Lexer/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">1. Kaleidoscope: Tutorial Introduction and the Lexer</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM-Tutorial/">LLVM Tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/LLVM-Tutorial/" style="font-size: 10px;">LLVM Tutorial</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/12/6-Kaleidoscope-Extending-the-Language-User-defined-Operators/">6. Kaleidoscope: Extending the Language: User-defined Operators</a>
          </li>
        
          <li>
            <a href="/2018/01/12/5-Kaleidoscope-Extending-the-Language-Control-Flow/">5. Kaleidoscope: Extending the Language: Control Flow</a>
          </li>
        
          <li>
            <a href="/2018/01/11/4-Kaleidoscope-Adding-JIT-and-Optimizer-Support/">4. Kaleidoscope: Adding JIT and Optimizer Support</a>
          </li>
        
          <li>
            <a href="/2018/01/11/3-Kaleidoscope-Code-generation-to-LLVM-IR/">3. Kaleidoscope: Code generation to LLVM IR</a>
          </li>
        
          <li>
            <a href="/2018/01/10/2-Kaleidoscope-Implementing-a-Parser-and-AST/">2. Kaleidoscope: Implementing a Parser and AST</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 LiTong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>